\section{Обзор}

Для C++ существует несколько применяемых подходов к реализации сборки мусора.
Их принято разделять на три основных класса\cite{CppArt}:
\begin{enumerate}
\item консервативный подход;
\item подходы, основанные на "умных" указателях;
\item введение новых примитивов, используемых для организации ссылок на автоматически управляемую память.
\end{enumerate}
Описание каждого из вышеизложенных подходов приведено далее в соответствующих подчастях.

\subsection{Консервативный подход}
Консервативный подход заключается в том, что, не имея возможности точного выявления указателей в памяти программы,
указателем считается любое значение в памяти, которое может таковым являться.
Одной из основных задач при реализации консервативного сборщика мусора является разработка алгоритмов
и/или критериев, согласно которым принимается решение о том, является то или иное значение в памяти указателем,
или же оно случайным образом попадает в диапазон адресов кучи.

Наиболее популярным сборщиком мусора для С++ является BoehmGC\footnote{\cd{http://www.hboehm.info/gc/}}.
Он использует именно консервативный подход к сборке мусора.
BoehmGC подменяет функции работы с памятью на аналогичные, реализованные его разработчиками,
сохраняя метаинформацию о выделяемых объектах.
При идентификации указателей в памяти одним из тестов на их легитимность является проверка
на то, совпадает ли конретное значение со значением указателя, полученного как результат
выделения памяти, и существует ли метаинформация, ему соответствующая.
Одной из основных причин использования BoehmGC консервативного подхода является тот факт,
что подобный подход накладывает минимальные ограничения на пользовательскую программу.
Одной из целей, которой придерживаются разработчики BoehmGC, является совместимость с уже существующими
программами, написанными на C++, без внесения каких-либо изменений в их исходный код\cite{BoehmTransGC}.
BoehmGC может использоваться не только в качестве сборщика мусора, но и как детектор утечек памяти в программе.

Основным недостатком консервативных сборщиков мусора является отсутствие возможности идентификации
всего скопившегося мусора. Чем больше данных обрабатывает программа, тем больше вероятность случайного совпадения
какого-то значения в памяти со значением указателя. Поэтому при обработке большого количества данных
консервативность сборщика мусора может стать проблемой, которая может привести к исчерпанию памяти,
которого могло бы не произойти, будь собран весь скопившейся мусор.
Конечно, в подобной ситуации не всегда происходит исчерпание памяти, однако большое количество несобранного мусора
может повлечь за собой неоправданные задержки в работе самого сборщика мусора.

\subsection{"Умные" указатели}
"Умный" указатель (smart pointer) --- это класс, реализующий интерфейс указателя, предоставляющий некоторую
дополнительную функциональность.
"Умные" указатели способны облегчить процесс управления динамической памятью, при условии их правильного использования,
однако не являются панацеей, позволяющей избежать всех проблем управления памятью в C++\cite{smartPointers}.

Некоторые из "умных" указателей реализуют программную идиому RAII (Resource Acquisition Is Initialization).
Смысл RAII заключается в том, что использются некоторые механизмы, неразрыно связывающие получение ресурса с его инициализацией,
а освобождение --- с уничтожением объекта. Зачистую "умные" указатели, использующие RAII, представляют собой классы,
инкапсулирующие владение памятью. Подробнее про RAII можно прочитать в \cite{CppPrinciples}.
Одним из представлителей подобного подхода является \lstinline[language= cpp]{auto_ptr}.
\lstinline[language= cpp]{auto_ptr} использует семантику разрушающего копирования, что не позволяет использовать его
в контейнерах стандартной библиотеки\cite{smartPointers}.
Существуют и более универсальные "умные" указатели, такие как \lstinline[language= cpp]{shared_ptr},
реализующий совместное владение объектом, и \lstinline[language= cpp]{weak_ptr} представляющим собой указатель,
не владеющий экземпляром объекта.
Для реализации совместного влядения \lstinline[language= cpp]{shared_ptr} использует алгоритм \textit{подсчёта ссылок}.
Подсчёт ссылок заключается в том, что у каждого объекта есть счётчик, называемый \textit{счётчиком ссылок},
значение которого увеличивается на единицу
при появлении очередной ссылки на объект, и уменьшается на неё же, при разрушении какой бы то ни было ссылки на этот объект.
Как только счётчик ссылок становится равным нулю, это означает, что на объект более никто не ссылается и его можно удалить.

Существует множество "умных" указателей, использующих подсчет ссылок для определения времени жизни объекта:
\lstinline[language= cpp]{boost::intrusive_ptr, boost::scoped_pt, boost::scoped_array<>, boost::shared_array<>},
также существуют реализации в библиотеках Loki\cite{Alexandrescu}, Poco\footnote{\cd{http://pocoproject.org/}} и многих других.
Основным преимуществом алгоритма посчёта ссылок является простота его реализации и понимания программистом.
Камнем же преткновения вышеописанного алгоритма является выявление \textit{циклических ссылок}, т.е. когда два объекта
напрямую или косвенно ссылаются друг на друга. В случае возникновения циклических ссылок, счётчик ссылок никогда не обнулится,
и память не будет освобождена, даже если объекты, связанные циклическими ссылками, уже не являются доступными.
Сами по себе "умные" указатели не решают проблемы выявления циклических ссылок, возлагая ответственность на программиста.
При реализации сборщика мусора, основанного на использовании "умных" указателей с алгоритмом подсчёта ссылок,
реализация детектора циклических ссылок является одной из основных и нетривиальных задач.
Конечно, существуют алгоритмы обнаружения циклических ссылок, однако время, затрачиваемое на их обнаружение,
зачастую не оправдывает их использование.

\subsection{Введение дополнительных примитивов}
Данный подход к сборке мусора заключается в введении нового примитива в язык, подобно "умному" указателю,
представляющего собой ссылку в автоматически управляемую память, и предоставления функции выделения автоматически управляемой
памяти под введенный примитив.
Основным преимуществом такого подхода является возможность реализации точной сборки мусора с использованием различных алгоритмов.
Именно этого подхода и придерживается реализуемая библиотека сборки мусора.
Одним из сборщиков мусора, реализующих подобный подход, является GC++\footnote{\cd{http://gcplusplus.sourceforge.net/classGCpp\_1\_1gc\_\_ptr.html}}. В силу своей простоты он имеет ряд ограничений, которых можно было бы избежать.
Так, например, в нём не поддерживаются массивы и множественное наследование в силу особенностей реализации.

Основными недостаткоми данного подхода являются следующие:
увеличение времени исполнения кода по сравнению с ручным управление памятью
и использование большого количества памяти для хранения метаинформации.
Однако подобными недостатками в той или иной степени обладают все подходы к сборке мусора в C++.