\section{Примеры}
%http://hboehm.info/gc/gc\_bench/GCBench.cpp
В данной части работы приведены примеры использования реализованной библиотеки неконсервативной сборки мусора.

\subsection{Совмещение ручного и автоматического управления памятью}
Здесь приведен простой пример совмещения автоматического и ручного управления памятью,
демонстрирующий принцип написания подобного кода.
Код подробно прокомментирован.

%\lstinputlisting[language= cpp, name = Совмещение ручного и автоматического управления памятью]{codes/manual_and_automatic_memory_management.cpp}
\begin{lstlisting}[language= cpp, mathescape=true, caption=Совмещение ручного и автоматического управления памятью]
#include <libgc/libgc.h>
#include <iostream>

struct str2 {
  gc_ptr<int> p;
};

struct str1 {
  gc_ptr<str2> p;
};

int main (void) {
  /// $\mbox{Выделение памяти под "ручной" объект типа str1}$
  str1 * s = (str1 *) malloc (sizeof(str1));
  /// $\mbox{Выделение управляемой памяти под управляемый объект}$
  /// $\mbox{внутри "ручного"}$
  s->p = gc_new<str2>();
  /// $\mbox{Вызов функции register\_object, сообщающей сборщику мусора,}$
  /// $\mbox{что на управляемый объект, расположенный в памяти по адресу}$
  /// $\mbox{\&(s->p), появилась дополнительная "внешняя" ссылка}$
  register_object(&(s->p));
  /// $\mbox{Выделение управляемой памяти под управляемый массив}$
  s->p->p = gc_new<int>(1000);
  
  /// $\mbox{Принудительный вызов сборки мусора.}$
  /// $\mbox{После выполнения данной функции ни один выделенный объект}$
  /// $\mbox{не должн быть удален, т.к.}$
  /// $\mbox{объект s --- ручной,}$
  /// $\mbox{объект s->p --- управляемый, на который существует ссылка из ручного,}$
  /// $\mbox{объект s->p->p --- управляемый, на который существует ссылка}$
  /// $\mbox{из автоматического, достижимого из "ручного"}$
  mark_and_sweep();
  
  /// $\mbox{Сообщение сборщику мусора о том, что на объект,}$
  /// $\mbox{лежащий по адресу \&(s->p) одна из ссылок из}$
  /// $\mbox{"ручных" объектов более не требуется}$
  unregister_object(&(s->p));
  s->p = NULL;
  
  /// $\mbox{Принудительный вызов сборки мусора.}$
  /// $\mbox{После выполнения данной функции объекты}$
  /// $\mbox{s->p и s->p->p должны быть удалены.}$
  mark_and_sweep();
  
  /// $\mbox{Вызов функции transfer\_to\_automatic\_objects(void * s)}$
  /// $\mbox{переводит "ручной" объект, расположенный по адресу \&s,}$
  /// $\mbox{в управляемые.}$
  /// $\mbox{Фактически это означает, что объект s более не нужен}$
  /// $\mbox{пользователю и его можно удалить во время ближайшей сборки мусора}$
  transfer_to_automatic_objects(s);
  
  /// $\mbox{Принудительный вызов сборки мусора.}$
  /// $\mbox{После выполнения данной функции объект}$
  /// $\mbox{s должен быть удален.}$
  mark_and_sweep();

  return 0;
}
\end{lstlisting}

\subsection{АВЛ-дерево}
Данный пример представляет собой реализацию АВЛ-дерева.
Нетрудно заметить, что код, приведенный ниже, представляет собой "обычный" код на C++, где
изменились лишь функции выделения памяти, заменены указатели C++ на \lstinline[language= cpp]{gc_ptr}
и опущены функции освобождения памяти.

\lstinputlisting[language= cpp, caption= АВЛ дерево со сборкой мусора]{codes/avl_with_gc.cpp}

Затраты на сборку мусора на данном примере замедляют работу программы примерно на порядок.