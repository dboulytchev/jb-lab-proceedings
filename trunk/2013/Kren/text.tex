\documentclass[12pt,a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
\usepackage[a4paper,includeheadfoot,top=20mm,bottom=20mm,left=25mm,right=15mm]{geometry}
\usepackage{indentfirst}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{alltt}
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{geometry}
\usepackage{fontenc}
\usepackage{inputenc}
\usepackage{babel}
\usepackage{ucs}


\renewcommand\baselinestretch{1.5}
\renewcommand\contentsname{Оглавление}

\begin{document}
\lstset{language=C,inputencoding=utf8x,keepspaces=true,extendedchars=\true,captionpos=b,tabsize=3,frame=lines,keywordstyle=\color{blue},stringstyle=\color{red},numbers=left,numberstyle=\tiny,numbersep=5pt,breaklines=true,showstringspaces=false,basicstyle=\footnotesize,emph={label}}
\begin{titlepage}
\thispagestyle{empty}
\def\baselinestretch{1.0}
\begin{center}
	{\largeСАНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ \\ \vskip 0.3em {\large Математико-механический факультет \\ \vskip 0.7em{\large Кафедра информатики \\}}}
    \vspace*{0.15\textheight}
    \vfill
    {\large Крень Мария Владимировна}
    
    \vskip 2em
    {\huge Представление данных для сборки мусора}
    
    \vskip 1em
    {\large Курсовая работа} \\
    \vskip 2em
    {\normalsize \raggedleft 
    Научный руководитель:\\
    к.ф.-м.н. Д.Ю. Булычев
    \\[3em]
    \vspace*{0.08\textheight}
    \vfill
    {\centering Санкт-Петербург \\ 2013}
    }
\end{center}
\end{titlepage}


\tableofcontents    

\newpage
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\textit{Сборка мусора} — это один из способов автоматического управления динамической памятью.
Суть сборки мусора заключается в том, что память, которая в дальнейшем не понадобится, освобождается системой управления памятью автоматически. 
Для этого иногда запускается процесс, называемый сборкой  мусора.
Поскольку, в общем случае, невозможно точно определить момент, когда объект использован в последний раз и
больше не нужен, сборщики мусора используют для этого консервативную оценку.
В качестве такой оценки используется понятие достижимости объекта из достижимых объектов. 
Начальное множество достижимых объектов определяется аксиоматически в зависимости от платформы.

Сборка мусора обладает как достоинствами, так и недостатками.
По сравнению с ручным управлением памятью, автоматическое управление памятью безопаснее: программисту не нужно 
заботиться о том, когда освобождать память из-под объектов. 
Это дает гарантию того, что не возникнет некоторых ошибок, таких как:
висячий указатель, который возникает, когда объект освобождается несмотря на то, 
что все еще есть
указатели на него, или ошибка повторного освобождения памяти, 
когда программа пытается освободить память, которая уже  была освобождена, 
или при интенсивном выделении и освобождении памяти может возникнуть ситуация,
когда непрерывный блок памяти определенного размера не может быть выделен,
хотя суммарный объем свободной памяти вполне достаточен~\cite{gc1}.

С другой стороны при автоматическом управлении памятью могут возникнуть следующие проблемы:
\begin{enumerate}
\item[1)] Если на объект есть ссылки из других достижимых объектов, то он никогда не будет удален.
\item[2)] Во время работы программы, из-за работы сборщика мусора возникают паузы в случайные моменты времени, а их продолжительность не определена.
Помимо этого, приходится затрачивать время на отслеживание дополнительной информации по объектам.
\item[3)] Должны быть выполнены  требования для реализации сборщика мусора.
Во-первых, должна присутствовать возможность определить все указатели из любого объекта на другие элементы кучи.
Во-вторых, не должно быть никаких операций над указателями (логических, арифметических и т.п.).
\end{enumerate}
Целью данной работы являются изучение существующих наиболее используемых моделей представления данных для сборки мусора и
разработка библиотеки, реализующей типичную модель.

\newpage
\section{Обзор существующих реализаций}

С появлением полиморфизма возникла проблема определения типа объекта. При полиморфизме, во время выполнения программы,
объекты производного класса могут рассматриваться,
как объекты базового класса в таких местах, как параметры метода и коллекции
массивов. При этом объявленный тип объекта больше не идентичен его типу во время выполнения программы.
Сборщик мусора должен уметь различать значения данных различных объектов.
В первую очередь он должен быстро отличать указатель от не указателя и определять тип указателя,
т.е. указатель это на ``boxed''  или ``unboxed''  значение.
``Boxed'' — значения данного типа представлены указателем на объект в куче. 
``Unboxed''  — тип, при котором никакой информации о сущности объекта данного типа мы получить не можем, кроме его значения.
Основной подход к проблеме определения типов — хранение метаданных.
Самым простым примером метаданных являются теги.
Обычно выделяется всего несколько бит под кодировку информации о типе.
Например, интерпретатор
GNU Еmacs Lisp поддерживает 24-битные целые несмотря на то,
что машинное целое 32-битное.
Восемь бит используется для хранения информации о типе, необходимой интерпретатору.
Числа с плавающей точкой делают ``boxed'', по-другому их хранить не выгодно.

Далее представлен обзор некоторых моделей представления данных.

\subsection {Java Virtual Machine(JVM)}
JVM (сокращенно Java VM, JVM)\footnote{http://docs.oracle.com/javase/specs/jvms/se7/html/index.html} —
виртуальная машина Java 
— основная часть исполняющей системы Java,
так называемой Java Runtime Environment (JRE).
Виртуальная машина Java интерпретирует байт-код Java,
предварительно созданный из исходного текста Java-программы
компилятором Java.

Для каждого ``unboxed'' типа Java существует свой класс-обертка.
Такой класс является неизменяемым (то есть, для
изменения значения необходимо создавать новый объект).
Все классы-обертки содержат статическое поле TYPE, содержащее объект
Class, соответствующий оборачиваемому типу.
При создании объекта такого класса, JVM хранит~\cite{java1}:
\begin{enumerate}
\item[1)]заголовок объекта;
\item[2)]данные объекта.
\end{enumerate}
Каждый экземпляр класса содержит заголовок~\cite{java2}. Заголовок для 
большинства JVM (Hotspot, openJVM) состоит из двух или трех машинных слов.

Структура заголовка:
\begin{itemize}
\item Mark Word — содержит хэш код объекта, информацию для системы управления памятью, информацию о состоянии блокировки. 
\item Type Information Block Pointer (TIBP) — содержит информацию о типе объекта (содержит объект Class — указатель на сведения о классе, который описывает тип объекта).
\item Array Length — если объект — массив, то заголовок расширяется словом для хранения длины массива.
\end{itemize}            
Чтобы отличить указатель от не указателя, нужно из TIBP получить методом getType тип объекта~\cite{java.lang,java}.

\subsection {Parallel Haskell compiler}
Parallel Haskell compiler (pHc)~\cite{pHc} — компилятор для языка Haskell.
Типизация в Haskell строгая, статическая, с автоматическим выводом типов.
Полиморфизм сложно реализовать с данными не фиксированного размера, 32-битные
числа с плавающей точкой слишком малы для решения многих научных проблем. Обычно
числа с плавающей точкой хранят, как ``boxed''. 
Они очень неэффективны, и к тому же, требуют дополнительные операции в памяти.
В данной модели представления данных все объекты 64-битной ширины, включая числа с плавающей точкой.
Рассмотрим модели данных в pHc.

Integers/pointer bit — модель, каждый образец которой --- знаковое целое 64-битной ширины, 
во многих случаях являющееся также указателем.

Floating point bit — модель, образец которой --- число с плавающей точкой 64-битной ширины стандарта IEEEE-754.

Если значение объекта
меньше чем 0х8FF0...,
тогда, это либо целое число, либо число с плавающей точкой,
иначе это указатель.

Минусы такого представления данных: 
\begin{enumerate}
\item Неэффективная арифметика (из-за размеров целых чисел)
\item Если происходит необработанное переполнение, то интерпретатор может 
подумать, что это указатель, вместо отрицательного числа.
\end{enumerate}
\subsection {Guile}

Guile\footnote{http://www.gnu.org/software/guile/manual} — интерпретатор и компилятор для языка Sheme.
Язык Sheme\footnote{cs.princeton.edu/picasso/mats} динамически типизирован.
Т.е. система не может определить тип данного выражения во время компиляции, тип может быть определен только во время выполнения.
Переменные в Sheme не имеют фиксированных типов, т.е. могут быть
типа <<пара>> в один момент времени, потом целочисленного типа, а потом <<вектором>> из тысячи элементов. Значения
имеют фиксированный тип. Представление каждого значения должно содержать достаточно
информации для точного определения типа во время выполнения.

Из-за переменных <<пар>> и <<векторов>>, которые могут хранить значения любых типов,
в реализации Sheme использовано общее представление для значений — 
один большой тип, которого достаточно для хранения значения или указателя на значение,
перед которыми идет необходимая информация о типе.

Самый простой способ представить значение в Sheme на С — это сделать его указателем на структуру, содержащую идентификатор типа, а после него объединение 
 значений:
\begin{alltt}
1  enum type \{ integer, pair, string, vector, ... \};
2  
3  typedef struct value *SCM;
4  
5  struct value \{
6    enum type type;
7    union \{
8      int integer;
9      struct \{ SCM car, cdr; \} pair;
10     struct \{ int length; char *elts; \} string;
11     struct \{ int length; SCM  *elts; \} vector;
12     ...
13   \} value;
14 \};
\end{alltt}

Обратившись к полю type в структуре, можно отличить указатель от не указателя~\cite{guile}.

\subsection {CHICKEN}

CHICKEN — это компилятор для языка Sheme.
В реализации CHIСKEN использован довольно простой и эффективный метод представления данных.
Отводятся биты под метаданные. Для этих битов существуют коды, которые отвечают за
принадлежность объектов к моделям и типам. Коды хранят специальную информацию о состоянии объектов.
В  модели представления данных данного компилятора
существует два вида объектов: immediate и non-immediate.
\begin{enumerate}
\item Immediate объекты.
Объекты данного типа либо 32-битной, либо 64-битной ширины, в зависимости от архитектуры.
\item[1)] Fixnums — самый маленький точный integer, в котором младший порядковый бит 
установлен 1, остальные 31 бит или 63 бита остаются под значение.
\item[2)] Characters — здесь 4 младших бита 1010, 24 последующие бита под данные.
\item[3)] Booleans — последние 4 бита — 0110, а 5-й — 1, если true, 0 — false.
\item[4)] Другие значения — последние 4 бита — 1110, следующие 4 кодируют тип одного из:
\begin{itemize}
\item C\_SCHEME\_END\_OF\_LIST — 0000;
\item C\_SCHEME\_UNDEFINED — 0001;
\item C\_SCHEME\_UNBOUND — 0010;
\item C\_SCHEME\_END\_OF\_FILE — 0011.
\end{itemize}
\item Non-immediate объекты.
Это блоки данных, представленные указателями в куче.
Первое слово блока данных содержит заголовок, оно дает информацию о типе объекта. 
Двадцать четыре младших бита заголовка хранят длину данного объекта.
Четыре старших бита заголовка используется для сборки 
мусора.
После этих четырех бит идут следующие четыре, представляющие собой один из 15 типов или специальную метку.
\end{enumerate}
В данной модели представления данных два младших бита отвечают за принадлежность объекта к той или иной 
группе. Например, если самый младший бит и следующий за ним равны единице, то это объект типа fixnum.
Когда помечен только следующий после младшего бит, то это объект типа non-immediate.
Таким образом, отличить указатель от не указателя в данной модели мы можем за одну операцию~\cite{chiken}.
\subsection {OСaml}
OCaml\footnote{http://ocaml.org/} — современный объектно-ориентированный язык функционального программирования общего назначения. 
Инструментарий OCaml включает в себя интерпретатор, компилятор в байткод и машинный код~\cite{ocaml2}.
Реализация представления данных в OCaml имеет специфическую особенность:
значения представленны либо в виде целого, либо в виде указателя.
Два младших бита указателя всегда 0 для 32-битной системы, для 64-битной 3 младших бита всегда 0. У целых младший бит — 1. 
Таким образом отличить целое от указателя можно за одну операцию.

Объекты больше или более сложные, чем простое целое, хранятся в OСaml в блоках.
Блок в OCaml состоит из заголовка и массива слов. Слово содержит 4 или 8 байт, это зависит от разрядности платформы.
Если у нас есть значение — указатель на блок,
тогда этот указатель указывает на 0-й элемент массива, а
заголовок --- это отрицательное смещение указателя на 4 или 8 байт.
Строка в OCaml хранится, как массив байт,
с достаточным количеством слов, выделяемых для требуемого размера строки.
Массив хранится, как массив значений,
каждое слово соответствует одному значению.

Заголовок в OCaml представляет из себя:
\begin{enumerate}
\item[1)] Количество слов в блоке, например, длину массива. Для 32-разрядных систем эта часть занимает в заголовке 22 бита.
\item[2)] Далее идет тег, который используется, для определения, что это строка содержит информацию для сборки мусора~\cite{ocaml}.
\end{enumerate}



\newpage
\section {Проделанная работа}

В данном разделе описывается прототип модели представления данных,
подходящий для представления объектов в языках со статической типизацией, 
т.е. в языках, в которых переменная, параметр подпрограммы и
возвращаемое значение функции связываются с типом 
в момент объявления и тип не может быть изменён позже
(переменная или параметр будут принимать, а функция 
— возвращать значения только этого типа).
Модель построена на основе существующих моделей,
некоторые из которых были представлены в обзоре.
Можно заметить, что ряд компиляторов используют модели схожие с 
представленными ниже. 
Например, в моделях JVM
есть заголовок и значение, во всех ниже представленных моделях есть заголовок,
в представлении массивов в JVM используются смещения указателей,
как и в этой работе,
но для хранения указателей в структурах. 
Как и в CHIСKEN, использованы теги для нумерации моделей,
а простейшие объекты представлены подобным образом.
В представленной ниже модели будем считать, что ``unboxed''  объект — это объект,
вмещающийся в одно машиннное слово (word\_t), 
никакой информации о сущности такого объекта, кроме его значения, мы получить не можем.
Объект является ``boxed'', если он принадлежит одному из пяти
типов моделей, описанных ниже, или на его хранение требуется больше,
чем одно машинное слово (word\_t).

Рассмотрим модели (рис. 1). Первые три модели (Model\_4, Model\_3, Model\_2) имеют общую структуру, различающуюся лишь тегом и типом хранимых объектов.
Структура:
\begin{enumerate}
\item[1)] Поле TAG — хранит в себе номер модели. Размер тега — 3 бита, данный размер выбран из-за количества моделей, их 5.
\item[2)] Поле SIZE — хранит в себе количество слов в объекте. Размер в памяти, отводимый для SIZE, зависит от размера машинного слова и вычислется как sizeof(word\_t)-3.
\item[3)] Массив слов — хранит данные, тип которых определяется моделью.
\end{enumerate}

\begin{figure}[h]
%\centering
\includegraphics[width=0.65\textwidth]{1}\\
\caption{структура первых трех моделей}
\end{figure}

\begin{itemize}
\item Model\_4 — массив указателей на ``unboxed'' значения, помещающиеся в одно слово.
Тег у данной модели равен 100.
\item Model\_3 — массив указателей на ``boxed'' значения.
Тег у данной модели равен 100.

\item Model\_2 — объект без указателей, хранит массив значений ``unboxed''.
Тег у данной модели равен 010.

\item Model\_1 — объект, расположение и тип указателей в котором представлены массивом смещений(рис. 2):
\begin{enumerate}
\item[1)] Поле TAG — такой же, как и в предыдущих трех моделях. Значение тега равно 001.
\item[2)] Поле SIZE — такой же, как и в предыдущих трех моделях.
\item[3)] Поле N — один байт отводится на хранение количества указателей.
\item[4)] N ячеек — смещение указателя и метка(указатель это на ``unboxed'' или ``boxed''  значение), каждая ячейка размера sizeof(word\_t), где 1 бит отводится под метку). 
\item[5)] Cлова с данными — занимают размер  size * sizeof(word\_t), количество слов умножить на размер машинного слова.
\end{enumerate}

\begin{figure}[h]
%\centering
\includegraphics[width=1\textwidth]{2}\\
\caption{Model\_1}
\end{figure}

\item Model\_0 — объект, расположение и тип указателей в котором представлены битовыми картами(рис. 3):
\begin{enumerate}
\item[1)] TAG — такой же, как и в предыдущих четырех моделях. Значение тега равно 000.
\item[2)] SIZE — такой же, как и в предыдущих четырех моделях.
\item[3)] Два битовых массива —  каждый из которых размером: (0.125 * size) + 1, в одном массиве хранятся смещения указателей, во втором метка (указатель на ``uboxed'' или ``boxed''  значение).
\item[4)] Cлова с данными — занимают размер size * sizeof(word\_t), количество слов умножить на размер слова.
\end{enumerate}
Смещения указателей записаны в битовый массив следующим образом: ptr.offset - (ptr.offset/CHAR\_BIT) * CHAR\_BIT;
Метка записывается, как и смещение.
\end{itemize}
\begin{figure}[h]
%\centering
\includegraphics[width=0.8\textwidth]{3}\\
\caption{Model\_0}
\end{figure}

Функции для работы с моделями:
\begin{enumerate}
\item \begin{alltt} size\_t get\_size(void * object) \end{alltt} — возвращает количество не пустых слов объекта; 
\item \begin{alltt}  word\_t get\_word(void * object, size\_t index)\end{alltt} — возвращает слово;
\item \begin{alltt} void * get\_ptr (void * object, size\_t index) \end{alltt} — возвращает указатель на слово;
\item \begin{alltt} void   set\_word(void * object, size\_t index, word\_t data)\end{alltt}  — записывает данные в слово;
\item \begin{alltt} void   set\_ptr (void * object, size\_t index, void* data)\end{alltt}   — записывает указатель;
\item \begin{alltt} PTR\_ITERATOR get\_iterator (void * object)\end{alltt} — создает итератор по указателям данного объекта;
\item \begin{alltt} void * next\_ptr(PTR\_ITERATOR * iterator) \end{alltt} — получает следующий указатель.
\end{enumerate}
Такое представление данных позволит нам за минимальное число операций различать объекты, совершать над ними примитивные операции.


\newpage
\section{Пример}
В данной секции описывается пример использования вышеописанных моделей данных.
В примере реализованы функции добавления клиента в список клиентов (add\_client), добавления рабочих в список рабочих (add\_workers), функции печати (print\_list\_workers, print\_list\_clients) списков и функция выбора (select\_client),
возвращающая из заданного числа списков рабочих всех клиентов с именами на заданную букву.  

\begin{lstlisting}
# include <stdio.h>
# include <prototype.h>

// функция с переменным числом аргументов, записывающая рабочих в структуру;
// имя рабочего записывается в паре с его идентификационным номером
// параметры функции: структура, хранящая рабочих и идекс рабочего, 
// количество добавляемых рабочих, имена
void  add_workers(void * list,int count, ...) { 
  va_list args;                                 
  va_start (args, count);
  // счетчик для итераций по всем словам структуры
  size_t i = 1;
  // счетчик для итераций с пустого слова структуры
  size_t j = 1;
  // количество непустых слов в структуре с рабочими 
  size_t len = get_size(list);
  if (count != 0) // если имен введено не ноль
  {
    // нахождение первого свободного слова в структуре
    for ( ; j < len + 1; j++) {  
      if ( get_word(list, j) == 0)  
      break;
    }
    if( j == len) {  // случай, когда возвращается индекс последнего слова
      return;  // без записи
    }
    else {  // случай, когда есть свободные ячейки
        // запись индекса и имя работника count раз
        for ( ; i < (size_t)(count+1); i++) {
          // берется следующее имя из параметров функции
          char * namels = va_arg(args, char *);
          // выделение памяти под объект с именем
          void * name = create_generic_object(strlen(namels), 0);  
          create_name(namels,name);  // запись имени в объект
          // запись индекса рабочего в структуру с рабочими
          set_word(list, j, (j+1)/2 );
          // запись указателя на объект с именем рабочего
          set_ptr(list, j+1, name);  
          j+=2;  // увеличивается индекс на 2, из-за попарного заполнения слов
         }
        }
  }
  return;
}
// функция записи имени в объект
void  create_name(char * name, void * res) {  // параметры: имя, объект
  size_t len = strlen(name); // вычисляется длина имени
  size_t i = 1;  // создается итератор по имени
  for (; i < len + 1; i++) {
    set_word(res, i, name[i-1]);  
    // итерации по имени и запись символов в объект
  }
  return ;
}

// функция с переменным числом аргументов, записывающая клиентов в ``boxed'' массив;
// парметры функции: массив, хранящий указатели на объекты с именами клиентов и  
// количество добавляемых клиентов, имена
void  add_client(void * list, size_t count, ...) {
    va_list args;
    va_start (args, count);
    // счетчик для итераций по всем словам массива
    size_t i = 1;
    // счетчик для итераций с пустого слова массива
    size_t j = 1;
    // количество непустых слов в массиве с клиентами  
    size_t len = get_size(list);
    if (count != 0)  // если имен введено не нуль
    {
        // нахождение первого свободного слова в массиве
        for ( ; j < len + 1; j++) { 
            if (get_word(list, j) == 0)
               break;
        }
        if( j == len) {  // случай, когда возвращается индекс последнего слова
          return;  // без записи
        }
        else {  // случай, когда есть свободные ячейки
            // запись имени работника count раз
            for ( ; i < (size_t)(count+1); i++) {
              // берется следующее имя из параметров функции
              char * namels = va_arg(args, char *);
              // выделение памяти под объект с именем
              void * name = create_generic_object(strlen(namels), 0);  
              create_name(namels,name);  // запись имени в объект
              // запись указателя на объект с именем клиента
              set_ptr(list, j, name);
              j++;
           }
          }
    }
    return;
}

// функция с переменным числом аргументов, выполняющая выборку клинтов;
// выборка производится из массива ``boxed'' указателей на списки клиентов,
// первых count рабочих, по букве ch
void * select_client(void * list_client_allworkers,
char ch, size_t count, ...)  {  
  va_list args;
  va_start (args, count);
  void * list_cl;  
  // результирующий массив  ``boxed'' указателей на объекты с именами 
  size_t all_num = 0;  // количество клиентов на заданную букву
  size_t i = 1;  // итератор по всем спискам клиентов
  size_t past = 1;  // счетчик записей имен
  for ( ; i < count + 1; i++) {
    // возвращает количество имен на букву ch из списка клиентов рабочего с таким id
    all_num += get_num_name(list_client_allworkers, i, ch);   
  }
  list_cl = create_boxed_array(all_num);  // выделяется память под массив
  i = 1;
  for ( ; i < count + 1; i++) {
    // запись указателей на объекты с нужными именами
    past = paste_name(list_cl, list_client_allworkers, i, past, ch);
  }
  return list_cl;
}

// возвращает количество имен на букву let из списка клиентов рабочего с таким id
size_t get_num_name(void * list_client_allworkers, size_t id, char let) {
void * ls_i = ((void *)get_word(list_client_allworkers, id));
size_t count = get_size(ls_i);
size_t i = 1;
size_t j = 0;
void * tmp;
      for (; i < count + 1; i++) {
          tmp = (void *)get_word(ls_i, i);
    if ( start_letter(tmp, let) == 1) {
      j++;
	}
      }
return j;
}

// функция сравнивает первую букву объекта и заданную let
size_t start_letter(void * obj, char  let) {
    if ( get_word(obj, 1) == (word_t)let)
    return 1;
  return 0;
}
// функция записывает в list\_cl клиентов на заданную букву let и 
// возвращает количество сделаных записей;
// аргументы: результирующий массив, массив клиентов, индекс клиента, буква
size_t paste_name(void * list_cl, void * list, size_t n,
size_t j, char let) {
void * ls_i = (void *)get_word(list,n);
size_t count = get_size(ls_i);
size_t i = 1;
for (; i < count + 1; i++) {
  if (start_letter( (void *)get_word(ls_i, i), let) == 1) {
    set_word(list_cl, j, get_word(ls_i, i));
    j++;
  }
}
return j;
}

// функция печати списка рабочих c индентификатором
void print_list_workers(void * list) {
    size_t len = get_size(list);
    size_t len2;
    void * nam1;
    size_t i = 2;
    size_t j ;
    word_t tmp;
    for (; i < (size_t)(len+1); i += 2) {
        tmp = get_word(list, i-1);
        printf("работник: " "%i ", (int)tmp);
        nam1 = (void *)get_word(list, i);
        if (nam1 != 0){
            len2 = get_size(nam1);
            for (j = 1; j < len2+1; j++) {
                tmp = get_word(nam1, j);
                printf("%c", tmp, tmp);
            }
            printf("\n");
        }
    }
}
// функция печати списка клиентов
void print_list_clients(void * list) {
    size_t len = get_size(list);
    size_t len2;
    void * nam1;
    size_t i = 1;
    size_t j;
    word_t tmp;
    for (; i< len+1; i++) {
        nam1 = (void *)get_word(list, i);
        if (nam1 != 0){
            len2 = get_size(nam1);
        for (j = 1; j < len2+1; j++) {
            tmp = get_word(nam1, j);
            printf("%c", tmp, tmp);
        }
        printf("\n");
    }
    }
}


int main () {
size_t ind[] = {1, 2, 3}; 

void * list_workers1;  // объявление структуры с рабочими 1
void * list_workers2;  // объявление структуры с рабочими 2

// выделение памяти под массивы указателей на имена клиентов
void * list_clients1 = create_boxed_array(15);  
void * list_clients2 = create_boxed_array(15);
void * list_clients3 = create_boxed_array(15);

// дескрипторы для структур
POINTER_DESCR p1 = { .offset = 0, .boxed = 1};
POINTER_DESCR p2 = { .offset = sizeof(p1) + 
sizeof(ind[0]), .boxed = 1};
POINTER_DESCR p3 = { .offset = sizeof(p1) + 
sizeof(ind[0]) + sizeof(p2)
+ sizeof(ind[1]), .boxed = 1};

// выделение памяти под структуры
list_workers1 = create_generic_object(6, 3, p1, p2, p3);
list_workers2 = create_bitmap(6, 3, p1, p2, p3);

// добавление рабочих
add_workers(list_workers1, 3, "lissi", "kttttl","susan");
add_workers(list_workers2, 3, "lis", "jake","san");

// добавление клиентов
add_client(list_clients1, 5, "otto", "aan", "alays",
"nata","deppy");
add_client(list_clients2, 3, "grey", "stenny", "alis");
add_client(list_clients3, 6, "mary", "max", "katty",
"alya", "asssa","ark");

// отведение памяти под массив указателей на списки клиентов
void * list_client_allworkers = create_unboxed_array(3);
// заполнение массива
set_ptr(list_client_allworkers, 1, list_clients1);
set_ptr(list_client_allworkers, 2, list_clients2);
set_ptr(list_client_allworkers, 3, list_clients3);
// вывод результатов
char letter = 'm';
printf("list_workers 1:" "\n");
print_list_workers(list_workers2);
printf("list_workers 2:" "\n");
print_list_workers(list_workers1);
printf("list_cl 1:" "\n");
print_list_clients(list_clients1);
printf("list_cl 2:" "\n ");
print_list_clients(list_clients2);
printf("list_cl 3:" "\n");
print_list_clients(list_clients3);
// вывод результата выборки на букву 'm'
printf("result_select:");
printf("clients_on_let " "%c\n", letter);
void * result = select_client(list_client_allworkers, letter, 3);
print_list_clients(result);
return 1;
}
\end{lstlisting}
В результате, с помощью функции печати, получается результат, совпадающий с дествительностью. На экран выводятся: ``mary'', ``max''.


\newpage
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}

Создание моделей представления данных является важным аспектом при организации сборки мусора. В данной работе был представлен
обзор существующих моделей представления данных, таких как: OCaml, CHICKEN, pHc, Guile, JVM. Описан прототип представления данных для динамически-типизируемых
языков. Для этого прототипа был приведен пример использования некоторых его функций.
\newpage
\bibliographystyle{ugost2008ls}
\bibliography{tex.bib}
\end{document}
