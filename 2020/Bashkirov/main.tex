
\newtheoremstyle{break}% name
  {}%         Space above, empty = `usual value'
  {}%         Space below
  {\itshape}% Body font
  {}%         Indent amount (empty = no indent, \parindent = para indent)
  {\bfseries}% Thm head font
  {.}%        Punctuation after thm head
  {\newline}% Space after thm head: \newline = linebreak
  {}%         Thm head spec

\interfootnotelinepenalty=10000

%\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt 

\def\backtick{\char18}


\lstdefinelanguage{ocaml}{
	keywords={fresh, conde, let, begin, end, in, match, type, and, fun, function,
		try, with, when, class, object, method, of, rec, nonrec, repeat, until, 
		while, not, do, done, as, val, inherit, new, module, sig, deriving, datatype,
		struct, if, then, else, open, private, virtual, include, is, or
	},
	sensitive=true,
	basicstyle=\ttfamily,
	commentstyle=\itshape\ttfamily,
	keywordstyle=\bfseries\ttfamily\bfseries\underbar,
	% keywordstyle=\ttfamilywithbold\underbar,
	identifierstyle=\ttfamily,
	basewidth={0.5em,0.5em},
	columns=fixed,
	fontadjust=true,
	literate={\$}{\$}1 {`}{$\backtick$}1 {->}{{$\to$}}2 {<-}{{$\leftarrow$}}2 {===}{{$\equiv$}}3 {=/=}{{$\not\equiv$}}3 {|>}{{$\triangleright$}}3,
	morecomment=[s]{(*}{*)},
	xleftmargin=0pt %\parindent
}

\lstdefinelanguage{lambda}{
	keywords={case, catch, default, switch, with},
	sensitive=true,
	basicstyle=\ttfamily,
	commentstyle=\itshape\ttfamily,
	keywordstyle=\bfseries\ttfamily\bfseries\underbar,
	% keywordstyle=\ttfamilywithbold\underbar,
	identifierstyle=\ttfamily,
	basewidth={0.5em,0.5em},
	columns=fixed,
	fontadjust=true,
	morecomment=[s]{(*}{*)},
	xleftmargin=0pt %\parindent
}

\lstdefinelanguage{haskell}{
	keywords={case, class, data, default, deriving, do, else, forall
    , if, import, in, infix, infixl, infixr, instance, let, module, 
    newtype, of, qualified, then, type, where, 
    foreign, ccall, as, safe, unsafe, pattern
	},
	sensitive=true,
	basicstyle=\ttfamily,
	commentstyle=\itshape\ttfamily,
	keywordstyle=\bfseries\ttfamily\bfseries\underbar,
	% keywordstyle=\ttfamilywithbold\underbar,
	identifierstyle=\ttfamily,
	basewidth={0.5em,0.5em},
	columns=fixed,
	fontadjust=true,
	literate={<-}{{$\leftarrow$}}3 {->}{{$\to$}}3 {=>}{{$\Rightarrow$}}3 {<=}{{$\leqslant$}}3,
	morecomment=[s]{(*}{*)},
	xleftmargin=0pt %\parindent
}

\lstdefinelanguage{scala}{
	keywords={def, case, trait, with, class, import, object, data, switch, if, while, for, final, extends, else, new, private, this, override, match, val, var},
	sensitive=true,
	basicstyle=\ttfamily,
	commentstyle=\itshape\ttfamily,
	keywordstyle=\bfseries\ttfamily\bfseries\underbar,
	% keywordstyle=\ttfamilywithbold\underbar,
	identifierstyle=\ttfamily,
	basewidth={0.5em,0.5em},
	columns=fixed,
	fontadjust=true,
	literate={<-}{{$\leftarrow$}}3 {=>}{{$\Rightarrow$}}3,
	morecomment=[s]{(*}{*)},
	xleftmargin=0pt %\parindent
}

\lstdefinelanguage{none}{
	keywords={},
	sensitive=true,
	basicstyle=\ttfamily,
	commentstyle=\itshape\ttfamily,
	keywordstyle=\bfseries\ttfamily\bfseries\underbar,
	% keywordstyle=\ttfamilywithbold\underbar,
	identifierstyle=\ttfamily,
	basewidth={0.5em,0.5em},
	columns=fixed,
	fontadjust=true,
	morecomment=[s]{(*}{*)},
	xleftmargin=0pt %\parindent
}

\lstset{
	mathescape=true,
	identifierstyle=\ttfamily,
	keywordstyle=\bfseries,
	commentstyle=\scriptsize\rmfamily,
	basewidth={0.5em,0.5em},
	fontadjust=true,
	language=ocaml
}

\title{Расширение конструкции сопоставления с образцом в языке OCaml}

\titlerunning{Расширение сопоставления с образцом}

\author{Башкиров Александр Андреевич}

\authorrunning{Башкиров~А.~А.}

\tocauthor{Башкиров~А.~А.}
\institute{St Petersburg State University\\
	\email{bash.spbu@gmail.com}}

\maketitle

\begin{abstract}
В данной работе проводится исчерпывающий обзор конструкций сопоставления с образцом в функциональных языках программирования со статической типизацией, а также предлагается собственный вариант с минимальным вмешательством в язык. На основании предложенных критериев и произведённого сравнения выделяется наиболее перспективное для реализации в языке OCaml расширение. Наконец в работе формализуются необходимые изменения в язык и компилятор OCaml версии 4.09 для реализации выбранной конструкции.
\end{abstract}

% У введения нет номера главы
\section*{Введение}
В контексте языков программирования сопоставление с образцом служит весьма эффективным и выразительным средством анализа данных. Появившееся в первых функциональных языках вкупе с алгебраическими типами данных эта конструкция довольно быстро завоевала популярность и в практически неизменном виде реализовывалась в большинстве последующих функциональных языков. Были разработаны эффективные схемы компиляции \cite{fessant2001optimizing, maranget2008decisiontrees, scott2000whendo}, проверки на полноту (pattern exhaus\-ti\-ve\-ness) \cite{maranget2007warnings} и хрупкость (pattern fragility). Более того, в настоящее время сходные конструкции разрабатываются и добавляются и в некоторые лидирующие императивные языки, такие как C\#~\cite{csharp2019pattern_matching}, Kotlin~\cite{kotlin2019when_expression} и Java~\cite{java2019proposal}. 

Однако в своем наиболее распространённом варианте этот приём имеет довольно серьёзные ограничения: 

\begin{itemize}
  \item конструкторы данных должны быть открытыми (public), что не допускает абстракции определения типа данных; 
  \item для каждого типа данных возможно лишь одно представление для использования в конструкции сопоставления с образцом; 
  \item охранные выражения (pattern guards) либо не допускаются языком (как в языке Standard~ML~\cite{milner1997definition}), либо могут содержать ровно одно булево выражение (как в языке OCaml на текущий момент~\cite{leroy2019manual});
  \item семантика сопоставления с образцом жёстко зафиксирована на уровне языка и не допускает определяемых пользователем вычислений\footnote{Изменение семантики конструкции сопоставления с образцом путем параметризации образцов типами специального класса типов представлено в секции 6.3 работы \cite{syme2007extensible}.}.
\end{itemize}

К настоящему времени было предложено множество различных вариантов расширения сопоставления с образцом, решающих упомянутые проблемы и предоставляющих дополнительные возможности. В попытке сравнения существующих решений можно рассмотреть их классификацию по виду устраняемых ограничений, возникающих в следующих случаях. 

\begin{enumerate}
	\item \textit{Со стороны определения образца:} лист может быть только открытым конструктором типа или константой; заметим также, что при этом, как правило, он не является значением первого порядка (first class value).
	\item \textit{Со стороны определения сопоставления:} сопоставление с образцом может являться только списком правил, а его семантика жёстко зафиксирована на уровне языка.
\end{enumerate}

В этой работе мы предъявим два независимых расширения языка для устранения каждого типа ограничений. Однако отметим, что в этой работе способы модификации семантики сопоставления с образцом~\cite{syme2007extensible, tullsen2000firstclass} рассматриваться не будут.

Основным подходом к расширению образцов является возможность проведения некоторых вычислений при сопоставлении, благодаря чему становятся возможными абстракция и задействование нескольких представлений при в сущности столь же выразительном синтаксисе. Многие языки программирования уже содержат подобные конструкции в том или ином виде: active patterns в F\# \cite{syme2007extensible}, pattern synonyms в Haskell \cite{pickering2016pattern} и extractors в Scala \cite{emir2007objects}. В данной же статье мы предложим расширение для языка программирования общего назначения OCaml.

\subsection*{Постановка задачи}
\noindent Целью работы является разработка расширение языка OCaml, которое бы:

\begin{itemize}
  \item удовлетворяло требованию \textit{консервативности} (или обратной совместимости) -- синтаксис и семантика любой программы, не использующей средства расширения, должны оставаться неизменными;
  \item являлось полностью статически типизируемым;
  \item не требовало модификации системы типов языка; 
	\item допускало абстракцию образцов;
	\item сохраняло возможность проверки сопоставления на полноту;
	\item позволяло оперировать образцами как значениями первого \mbox{порядка};
  \item не требовало модификации существующих модулей.
\end{itemize}

\noindent Были поставлены следующие задачи:

\begin{enumerate}
	\item Провести анализ существующих решений и выполнить сравнение по ряду объективных критериев. По результатам обосновать выбор того или иного существующего решения или представить собственное.
	\item Формализовать изменения, которые необходимо внести в компилятор языка OCaml, для поддержки нового расширения:
  
  \begin{itemize}
  \item расширение синтаксиса
  \item правила типизации новых конструкций
  \item компиляция расширения в промежуточное представление
  \end{itemize}
  
  \item Представить прототип реализации выбранного расширения.
\end{enumerate}

\section{Обзор}

\subsection{Views}
Ф. Вадлер (Philip Wadler) \cite{wadler1987views} одним из первых указал на недостатки традиционной модели образцов: сопоставление с образцом является мощным выразительным средством и ясно (в некоторых случаях почти досимвольно) выражает индуктивные математические определения, но требует открытого представления типа. Абстракция данных поддерживает \mbox{эффективность}\footnote{В качестве примера можно рассмотреть представление натуральных чисел в виде эффективного машинного типа целого числа и совершенно неэффективное, но формальное и удобное представление в виде алгебраического типа данных согласно математическому определению Пеано. Подробнее см. в \cite{wadler1987views}.} и инкапсуляцию, но требует скрыть представление типа -- таким образом программист оказывается перед дилеммой выразительного или эффективного кода. 

Для решения этой проблемы Ф.~Вадлер предложил концепцию \textit{представлений} (views): определяемое представление состоит из целевого типа данных, по которому проводится сопоставление с образцом, и двух функции in и out, которые определяют преобразование в  целевой тип данных и обратно соответственно. Можно определить несколько представлений с соответствующими преобразованиями и экспортировать их вместе с настоящим устройством типа или без него, при этом для пользователя они будут равноправны. Интересно заметить, что в терминах представлений могут быть выражены такие особенности сопоставления с образцом как as-образцы и охранные булевы выражения.

Сама концепция представлений оказалась довольно успешной, были представлены реализации для языков Miranda, Standard ML и Haskell. Однако имелись и серьезные недостатки: корректно определенное представление требует изоморфизма с исходным устройством типа, а функции in и out должны являться взаимно обратными. Это довольно серьезное ограничение, которое к тому же невозможно проверить средствами компилятора. Более того, наличие обеих функций вызывало проблемы с трактованием чистых (pure) вычислений как системы перезаписи (equational reasoning). Также при использовании представлений довольно сложно проследить, где будут происходить затратные вычисления. Ну и наконец содержательно одна и та же функциональность может быть реализована как функцией, так и представлением, которые подчас выражаются друг через друга, что приводит к шаблонному коду.

Поэтому в последующие несколько лет было предложено множество вариантов, устраняющих те или иные недостатки оригинальной концепции. Интересной представляется работа К.~Окасаки (Chris~Okasaki)~\cite{okasaki98views}: автор предложил вариант представлений для языка Standard ML, представителя семейства языков ML, к которому также принадлежит и OCaml. В своей работе К.~Окасаки ограничил представления до одной функции in, сняв тем самым требования изоморфизма и устранив проблемы с семантикой системы перезаписи, а так же показал, как представления встраиваются в систему модулей ML и каковы особенности использования функций с эффектами внутри таких представлений.

\subsection{Pattern guards and Transformational Patterns} \label{sec:pattern_guards}
Примерно в это же время был предложен альтернативный подход к данной задаче: М.~Эрвиг (Martin~Erwig) и С.~П.~Джонс (Simon Peyton Jones) представили два расширения сопоставления с образцом: охранные выражения и \textit{преобразующие} образцы (transformational patterns)~\cite{erwig2000pattern}. Охранные выражения позволяют в одной ветке разбора проводить нес\-колько последовательных сопоставлений. Ключевой здесь является возможность вычисления функции от привязанных переменных, результат которой также проходит сопоставление.  Такое простое и по синтаксису, и по семантике, и по реализации правило автоматически позволяет абстрагироваться по любому образцу, причем зачастую с возможностью использования уже существующих функций. 

К примеру, рассмотрим класс типов для простейшего списка:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=haskell]
class AbsList c where
  nil   :: c a
  cons  :: a -> c a -> c a
  head  :: c a -> Maybe (a, c a)
\end{lstlisting}
\end{minipage}

Тогда сопоставление с образцом можно записать как

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=haskell]
instance AbsList c => Functor c where
  fmap f l 
    | Just (x, xs) <- head l = f x `cons` fmap f xs
    | Nothing      <- head l = nil
\end{lstlisting}
\end{minipage}

В последовательно стоящих охранных выражениях можно использовать привязки из предыдущих:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=haskell]
filterMap :: AbsList c => 
             c a -> (a -> Maybe b) -> c b
filterMap f l
  | Just (x, xs) <- head l, 
    Just v  <- f x          = v `cons` filterMap f xs
  | Just (x, xs) <- head l,
    Nothing <- f x          = filterMap f xs
  | Nothing      <- head l  = nil
\end{lstlisting}
\end{minipage}

Таким образом любой одиночный образец для выражения типа $ \tau $ может быть представлен как функция \lstinline[breaklines]|pat :: $\tau$ $\to$ Maybe $\zeta$|, где $ \zeta $ являет собой некоторый кортеж, размерность которого определяет количество привязываемых при сопоставлении переменных, а его составляющие -- типы этих привязок. Отметим, что в этом смысле \lstinline[breaklines]|Maybe ()| эквивалентен \lstinline[breaklines]|Bool|, а неопровержимые (irrefutable) образцы могут представлены просто как \lstinline[breaklines]|irrPat :: $\tau$ $\to$ $\zeta$|. Используется \lstinline|pat| как

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=haskell]
f x
  | Just (...) <- pat x = ...
\end{lstlisting}
\end{minipage}

Заметим, однако, небольшую синтаксическую особенность -- при таком использовании первым зачастую идет неопровержимый образец, именующий само инспектируемое выражение (scrutinee) -- например, \lstinline|x| в выражении \lstinline|f x| выше. А уже образец, непосредственно разбирающий выражение, идет после, в охранном выражении. При этом, как в примере с \lstinline|filterMap|, если мы хотим применить функцию к одной из полученных привязок, необходимо записать это в следующем охранном выражении, что отличается от традиционной вложенной формы записи, при которой подобразцы записываются прямо на месте привязок. К тому же это вызывает дублирование отдельных охранных выражений, как с \lstinline[breaklines]|Just (x, xs) $\leftarrow$ head l| в примере с \lstinline|filterMap|.

Для устранения этой особенности в пользу более привычной формы записи в работе был предложен синтаксический сахар -- преобразующие образцы. Они позволяли записывать сопоставление с результатом функции непосредственно внутри образца. Правда, насколько нам известно, в первоначальном варианте, предложенном в работе, они так и не были реализованы, поскольку вместо них довольно быстро были добавлены так называемые \textit{представляющие} образцы (view patterns), реализующие ту же самую идею. Используя эту нотацию \lstinline|filterMap| можно переписать как 

\noindent
\raggedbottom
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=haskell]
{-# LANGUAGE ViewPatterns  #-}

filterMap f (head -> Just (f -> Just v,  xs))
  = v `cons` filterMap f xs
filterMap f (head -> Just (f -> Nothing, xs)) 
  = filterMap f xs
filterMap f (head -> Nothing)
  = nil
\end{lstlisting}
\end{minipage}

Подробное сравнение охранных выражений с представлениями приведено в самой работе \cite{erwig2000pattern}. Говоря кратко, в общем случае ни один из подходов не может быть выражен в терминах другого, но утверждается, что охранные выражения значительно проще для определения и реализации, позволяют использовать ранее написанные функции без дополнительных определений и явно отражают места, где могут происходить затратные вычисления.

Заметим также, что коль скоро образцы представлены функциями, они могут быть дополнительно параметризованы некоторым значением. Например, в этом смысле функция \lstinline|take| для класса типов \lstinline|AbsList| также представляет собой образец:

\noindent
\raggedbottom
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=haskell]
destutter l@(take 2 -> Just [f; s]) | f = s 
  = destutter (tail l)
destutter (head -> Just (x, xs)) 
  = cons x (destutter xs)
destutter (head -> Nothing)      
  = nil
\end{lstlisting}
\end{minipage}

Более того, образцы могут быть параметризованы другими образцами. Поддержка языком этого свойства крайне важна для реализации комбинаторов образцов (pattern combinators) \cite{tullsen2000firstclass}.

\subsection{Scala Objects patterns} \label{sec:scala_objects}
В работе \cite{emir2007objects} было предложено развитие идеи, что любой одиночный образец может быть представлен функцией типа \lstinline[breaklines]|pat :: $\tau$ $\to$ Maybe $\zeta$|. Образец в языке Scala определятся как функция \lstinline[breaklines]|unapply(obj: $\tau$):| \lstinline[breaklines]|Option[$\zeta$]|\footnote{Более полное и формальное определение вы можете найти в спецификации языка Scala: \\ \url{https://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html\#extractor-patterns}}, реализованная в некотором объекте, именуемом \textit{экстрактором}. 

Однако, по сравнению с представляющими образцами в Haskell при сопоставлении с образцом никаких дополнительных синтаксических элементов вроде \lstinline|->| или проверки с конструктором \lstinline|Just| не требуется, что позволяет писать более краткий и выразительный код. К примеру, аналогичное определение \lstinline|AbsList| и реализация функции \lstinline|filterMap| на языке Scala:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=scala]
trait AbsList[+A] {
  def nil[B]: AbsList[B]
  def cons[B,U>:B](hd: U, tl: AbsList[B]): AbsList[U]
  def head: Option[(A, AbsList[A])]
  // Extractor signatures:
  trait ConsExSig {
    def unapply[A](l: AbsList[A])
     : Option[(A, AbsList[A])] = l.head
  }
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=scala]
  trait NilExSig {
    def unapply[A](l: AbsList[A]): Boolean = 
      l.head.isEmpty
  }
  // Extractors
  val Cons = new ConsExSig {}
  val Nil  = new NilExSig  {}
}
\end{lstlisting}
\end{minipage}

%\begin{minipage}{\linewidth}
%\begin{lstlisting}[language=scala]
%final class AbsListImpl[+A](/* ... */) extends AbsList[A] {
%  // ...
%}
%\end{lstlisting}
%\end{minipage}

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=scala]
def filterMap[A, B](f: A=>Option[B], l: AbsList[A])
  : AbsList[B] = {
  import l._
  l match {
    case Cons(x, xs) if f(x).isDefined
                  => cons(f(x).get, filterMap(f, xs))
    case Cons(_, xs) => filterMap(f, xs)
    case Nil()       => nil
  }
}
\end{lstlisting}
\end{minipage}

Отметим, что приведённая реализация позволяет переопределять экстракторы в классах, реализующих свойство (trait) \lstinline|AbsList|.

В то же время охранные выражения в Scala могут содержать только булево выражение и не позволяют определять дополнительных привязок. При этом иногда, как и в примере выше, возникает ситуация, когда в охранном выражении нужно произвести некоторое вычисление и проверить его результат, а затем в случае успеха воспользоваться этим результатом внутри выражения -- вместо этого сейчас выражение \lstinline|f(x)| дублируется и более того вычисляется повторно. Чтобы избежать этой ситуации можно определить объект-обертку, реализующий \lstinline|unapply| \mbox{для \lstinline|f|:}

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=scala]
class Wrapper[A, B](f: A=>Option[B]) {
    def unapply(arg: A): Option[B] = f(arg)
}
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=scala]
def filterMap[A, B](f: A=>Option[B], l: AbsList[A])
  : AbsList[B] = {
  import l._
  val F = new Wrapper(f)
  l match {
    case Cons(F(v), xs) => cons(v, filterMap(f, xs))
    case Cons(_, xs)    => filterMap(f, xs)
    case Nil()          => nil
  }
}
\end{lstlisting}
\end{minipage}

Экстракторами могут быть произвольные объекты времени выполнения, класс которых содержит метод \lstinline|unapply| подходящего типа, что позволяет параметризацию образцов.

Также Scala предоставляет синтаксический сахар для разбора последовательностей. К примеру

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=scala]
def foo[A](l: AbsList[A]): Unit = {
  import l._
  l match {
    Cons(x, Cons(y, Cons(z, Cons(w, _)))) => () // 1
    AList(x, y, z, w, _ *)                => () // 2
    _                                     => ()
  }
}
\end{lstlisting}
\end{minipage}

Ветвь 2 представляет более краткий эквивалент ветви 1. Для применения такой нотации объект \lstinline|l| должен содержать объект-экстрактор \lstinline|AList|, реализующий метод \lstinline[breaklines]|unapplySeq[A](l: AbsList[A]):| \lstinline[breaklines]|Option[Seq[A]]|

Дополнительно отметим, что Scala поддерживает символьные инфиксные наименования классов, благодаря чему сопоставления с образцом также могут содержать символьную инфиксную нотацию. Например, \lstinline|::| в примере ниже реализовывается стандартными средствами языка, не требуя дополнительной синтаксической поддержки, как в языке OCaml:

\noindent
\raggedbottom
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=scala]
List(42) match {
  42 :: xs => true
  _        => false 
}
\end{lstlisting}
\end{minipage}

Как видно, экстракторы Scala являются мощным и выразительным средством для представления абстрактных образцов, возможно, требуя некоторых простейших объектов-оберток над замыканиями. Главным неудобством же является неявное отключение проверки на полноту при использовании экстракторов. Рассмотрим простейший пример

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=scala]
object MySome {
  def unapply[A](x: Option[A]): Option[A] = x
}

def unwrap(v: Option[Int]): Int = 
  v match {
    case MySome(i) => i
  }
\end{lstlisting}
\end{minipage}

В этом случае мы не получаем предупреждения от компилятора о неполноте сопоставления -- проблема заключается в том, что компилятор не может вывести какое значение в действительности не покрывается сопоставлением. А раз компилятор не обладает доказательством нарушения, проверка считается пройденной. 

Способом указания компилятору Scala на совместную полноту экстракторов является использование в качестве реализации типа данных иерархию из базового \textit{запечатанного} (sealed) класса и его наследников case классов, предоставляющих экстракторы по умолчанию -- такое решение снова нарушает абстракцию. Использование же case классов в качестве оберток над произвольными экстракторами с целью указания на их совместную полноту является сложной задачей даже для опытного Scala разработчика и требует значительных умственных и синтаксических затрат. 

%С этой проблемой можно бороться искусственно. Способ сказать компилятору об исчерпывающих вариантах сопоставления это использовать \lstinline|case| классы. Таким образом, экстракторы, которые мы хотим объединить как исчерпывающие, необходимо представить как \lstinline|case| классы, и дополнительно добавить объект обертку

\subsection{F\# Active Patterns} \label{sec:active_patterns}
Решение, предложенное в работе \cite{syme2007extensible} обладает схожей выразительностью и в то же время позволяет объединять отдельные образцы в один многозначный, сопоставление с которым может быть проверено на полноту. 

Например, для того же класса типов \lstinline|AbsList| (в ML-языках представляемого модулем) можно объединить образцы \lstinline|Cons| и \lstinline|Nil| в один неопровержимый двузначный образец:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=ocaml]
let (|Cons|Nil|) l =
  match head l with
  | Some(hd, tl) -> Cons(hd, tl)
  | None         -> Nil
\end{lstlisting}
\end{minipage}

В качестве примера использования рассмотрим функцию \lstinline|destutter|, удаляющую последовательные дубликаты элементов: 

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=ocaml]
let rec destutter = function
  | Cons(hd, Cons(hd', _) as tl) 
      when hd = hd' -> destutter tl
  | Cons(hd, tl)    -> cons hd (destutter tl)
  | Nil             -> nil
\end{lstlisting}
\end{minipage}

При этом будет произведена проверка на полноту, которую эта реализация пройдет благодаря второй и третьей ветвям, определяющим все возможные образцы для входного значения.

В такой реализации используются ``анонимные'' типы-суммы, имена конструкторов которых не зависят от предметной области и состоят лишь из имени типа и порядкового номера. Такие типы предопределяются языком F\#, к примеру

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=ocaml]
type ('a, 'b) choice =
  | Choice2_1 of 'a
  | Choice2_2 of 'b
\end{lstlisting}
\end{minipage}

Такое решение представляется также крайне удачным для реализации в языке OCaml, благодаря поддержке языком полиморфных вариантов, что любезно заметили авторы работы \cite{syme2007extensible}. Полиморфные варианты позволяют заменить анонимные типы на более информативные и гибкие конструкторы-метки, к примеру

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=ocaml,escapechar=@]
val (|Cons|Nil|) : 
  'a AbsList.t ->[@\textasciigrave@Cons of ('a * 'a AbsList.t) | @\textasciigrave@Nil]
\end{lstlisting}
\end{minipage}

Вместо

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=ocaml]
val (|Cons|Nil|) : 
  'a AbsList.t ->('a * 'a AbsList.t) choice
\end{lstlisting}
\end{minipage}

Помимо полных (total) образцов, предложенное расширение также позволяет определять и обычные частичные образцы в терминах все тех же функций с результирующим типом \lstinline[breaklines]|$\zeta$ option|. При этом образцы также могут быть параметризованы различными значениями, в частности, другими образцами.

С технической же точки зрения, авторы работы предложили модификацию схемы компиляции \cite{scott2000whendo}, отличную от используемой компилятором OCaml \cite{fessant2001optimizing}. Представляется интересным разработать модификацию схемы \cite{fessant2001optimizing} для внедрения подобного расширения.

\subsection{Haskell Pattern Synonyms}
Пожалуй, единственным недостатком активных образцов, предложенных для F\#, по сравнению с обычными образцами конструкторов типа, является тот факт, что первые можно использовать только в сопоставлении с образцом, но не для конструирования данных. Так в примере выше для разбора значения списка используется активный образец \lstinline|Cons|, а для конструирования отдельная функция \lstinline|cons|. При этом даже самое первое решение в виде представлений \cite{wadler1987views} позволяет использовать один и тот же терм образца в обоих случаях.

Предложенное в работе \cite{pickering2016pattern} решение в виде синонимов образцов позволяло определять \textit{неявные} (implicit) или \textit{явные двунаправленные} (expli\-cit bidirectional) образцы, термы которых можно использовать как для конструирования, так и для разбора значений. К примеру, для класса типов \lstinline|AbsList| можно определить

%\begin{minipage}{\linewidth}
%\begin{lstlisting}[language=haskell]
%class AbsList c where
%  nil  :: c a
%  cons :: a -> c a -> c a
%  head :: c a -> Maybe (a, c a)
%\end{lstlisting}
%\end{minipage}

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=haskell]
pattern Nil :: AbsList c => c a
pattern Nil <- (head -> Nothing) where
  Nil = nil
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=haskell]
pattern Cons :: AbsList c => a -> c a -> c a
pattern Cons x xs <- (head -> Just (x, xs)) where
  Cons x xs = cons x xs
\end{lstlisting}
\end{minipage}

Тогда эквивалентное определение функции \lstinline|destutter| с использованием синонимов образцов может быть записано следующим образом:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=haskell]
destutter Cons(hd, tl@Cons(hd', _)) | hd == hd' 
                       = destutter tl
destutter Cons(hd, tl) = Cons hd (destutter tl)
desturrer Nil          = Nil
\end{lstlisting}
\end{minipage}

Как видно, содержательно происходит тоже самое, но компилятор автоматически подставляет соответствующее действие на место терма. К сожалению, как подробно описано авторами в работе, цена у такого простого синтаксического сахара оказалась высокой: поскольку у одного терма может быть два определения, типы индуцированные этими определениями могут не совпадать. В работе представлен следующий пример:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=haskell]
pattern Q :: Ord a => a -> a -> (a, a)
pattern Q x y <- (x, y) where
  Q x y | x <= y    = (x, y)
        | otherwise = (y, x)
\end{lstlisting}
\end{minipage}

Здесь для конструирования требуется ограничение \lstinline|Ord|, в то время как для сопоставления нет. Сигнатура образца выводится только из определения сопоставляющей части. Поэтому в данном случае потребуется явно указать сигнатуру, поскольку выведенная окажется слишком общей: \lstinline|Q :: a -> b ->(a, b)|.

Уникальной особенностью предложенного расширения являлись гибкие сигнатуры образцов, которые позволяли выражать такие особенности системы типов как экзистенциальные квантификаторы и GADTs. Однако для его реализации в языках семейства ML потребуется серьезная адаптация, ввиду отсутствия активно используемых в расширении классов типов и подобных ограничений, функциональность которых в OCaml представлена значительно отличающейся системой модулей и функторов.

Недостатком синонимов образцов является отсутствие возможности группировки отдельных синонимов для указания на их совместную полноту по входному значению. Т.е. в терминах активных образцов F\# все синонимы образцов являются частичными (partial). Также, к сожалению, синонимы образцов не могут быть переданы напрямую в функцию и не поддерживаются в качестве составляющих класса типов, а их параметризация требует определения новых классов типов, что синтаксически чуть более тяжеловесно, нежели параметризация активного образца по месту использования.

\section{Оператор возврата к сопоставлению} \label{sec:generalized_backtracking}

В данном разделе мы представим собственное расширение сопоставления с образцом. Его особенностью является минимально возможное вмешательство в язык:

\begin{itemize}
\item требует введения в язык всего одного ключевого слова;
\item типизируется элементарно как $\forall a\ a$;
\item тривиально и достаточно эффективно встраивается в любую схему компиляции;
\item проверка на полноту также легко расширяется для учета новой особенности.
\end{itemize}

Вдохновением для такого дизайна послужила схема компиляции сопоставления с образцом в автомат поиска с возвратами (backtracking automata) \cite{fessant2001optimizing,augustsson1985compiling}, оптимизированный вариант которой используется сейчас в OCaml.

В простейшем варианте такой схеме компиляции на вход поступает матрица образцов и вектор значений. Первым шагом происходит применение \textit{разделяющего} правила (mixture rule \cite{fessant2001optimizing}), которое некоторым образом делит матрицу на группы последовательных строк, рекурсивно компилируемых другими правилами. При компиляции группы для случая, когда сопоставление внутри этой группы не удалось, генерируется бросание \textit{статического}\footnote{для которого на уровне компиляции известна точка обработки, а значит оно может быть скомпилировано в единственную инструкцию перехода} исключения. Разделяющее же правило ответственно за вставку статических обработчиков и линейное упорядочивание групп.

Рассмотрим пример компиляции слияния списков из \cite{fessant2001optimizing} в промежуточное представление компилятора OCaml (также подробно описанного в \cite{fessant2001optimizing}):

\noindent
\begin{minipage}{\textwidth}
  \begin{figure}[H]
    \begin{minipage}{0.40\textwidth}
\begin{lstlisting}[language=ocaml]
let merge lx ly = 
  match lx, ly with
  | []   ,  _    -> 1
  | _    , []    -> 2
  | x::xs, y::ys -> 3
\end{lstlisting}
    \end{minipage}
  \centering
    \begin{minipage}{0.55\textwidth}
\begin{lstlisting}[language=lambda]
catch
  (catch
    (switch lx with case []: 1
      default: exit)
  with (catch
    (switch ly with case []: 2
      default: exit)
  with (catch
    (switch lx with
      case (::):
        (switch ly with
          case (::) : 3
          default: exit)
      default: exit))))
with (failwith "Partial match")
\end{lstlisting}
    \end{minipage}
    
  \captionsetup{justification=centering}
  \caption{Простейшая компиляция слияния списков}
  \label{fig:simple_match}
  \end{figure}
\end{minipage}

\bigskip

Инициализация возврата к предыдущим сопоставлениям происходит бросанием статического исключения (оператор \lstinline|exit|), перехват которого (оператор \lstinline[language=none,breaklines]|catch ... with ...|) означает переход к рассмотрению следующей ветви. Такие команды бросания исключения генерируются самой схемой компиляции и только внутри разбора ветви.

Данное расширение предлагает позволить \textit{пользователю} инициировать такие возвраты, причем не только внутри образца, но и в теле ветви, т.е. уже после успешного разбора образцов. Для этого требуется добавить в язык \textit{оператор возврата к сопоставлению} (далее для краткости именуемый как оператор возврата), представляемый ключевым словом \lstinline|backtrack|. Идеалогически такая конструкция близка широко используемым в императивных языках операторам возврата из цикла \lstinline|break| и \lstinline|continue|, позволяющих ограниченное ручное управление потоком управления. 

Очевидно, что такое решение позволяет не только легко эмулировать обобщенные охранные выражения, но и избавляет их от проблемы дублирования префиксов разбора! Общий префикс выносится в во внешнее сопоставление, а различные суффиксы --- во внутреннее. Рассмотрим несколько модифицированный синтетический пример из \cite{discuss}, записанный на языке Haskell с использованием обобщенных охранных выражений:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=haskell, escapechar=@]
foo e1 e2 = 
  case e1, e2 of
    Nothing, true -> 1
    (Just x with Foo y   = lookup tbl x), false ->  y
    (Just x with Bar a,b = lookup tbl x), false ->a+b
    _, true -> 3
    _, false -> 4
\end{lstlisting}
\end{minipage}

Как видно, третья ветвь синтаксически дублирует вторую, отличаясь только глубоко вложенным образцом \lstinline[breaklines]|Bar a, b| (заметьте, что в такой вариации даже ИЛИ-образцы неприменимы). При этом нельзя перенести сопоставление с \lstinline|Foo| и \lstinline|Bar| во вложенное сопоставление, поскольку данные вида \lstinline[breaklines=true,language=none]|(Just x with Zet = lookup tbl x), false| \linebreak должны попасть в последнюю ветвь.

Оператор возврата помогает избавиться от дублирования образцов и естественно выразить задуманное:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=ocaml]
let t e1 e2 = 
  match[@label outer] e1, e2 with
  | None, true -> 1
  | Some x, false ->
      begin match lookup tbl x with
      | Foo y     -> y
      | Bar(a, b) -> a + b
      | _ -> backtrack%outer
      end
  | _, true -> 3
  | _, false -> 4
\end{lstlisting}
\end{minipage}

Заметьте, что оператору \lstinline|backtrack| требуется указание метки возврата, которые мы предлагаем записывать через систему атрибутов и расширений, служащих в языке OCaml специально для записи метаинформации.

Такой код будет скомпилирован в следующее промежуточное представление:

%\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=lambda, numbers=left]
catch
  (switch* e1 with 
    case None: (if (!= e2 0) 1 exit) 
    case Some:
      (if (!= e2 0) exit 
        (let (x (field 0 e1))
          (switch (apply lookup tbl x) with
            case Foo: (field 0 x)
            case Bar: (+ (field 0 x) (field 1 x))
            default : exit)))
with
  (if (!= e2 0) 3 4)
\end{lstlisting}
\end{minipage}

Здесь мы для краткости генерируемого кода использовали информацию о полноте \lstinline|switch| в строке 2 и опустили для него метку \lstinline|default|.

Обратите внимание на строку 10: стоящая там команда \lstinline|exit| является результатом компиляции оператора \lstinline|backtrack| и притом только она. Таким образом, мы получаем отображение \lstinline|backtrack| на \lstinline|exit| один к одному. В действительности не требуется более добавления никаких конструкций, даже \lstinline[language=none]|catch ... with ...|, которые будет введены автоматически правилом разделения, используя информацию о полноте.

В общем случае, разумеется, \lstinline|exit| необходимо снабдить индексом, поскольку иногда требуется подняться на более чем 1 уровень. Но актуальная схема компиляции \cite{fessant2001optimizing} уже обладает такими метками (введенными для оптимизаций), поэтому не требуется никакого усложнения существующего промежуточного представления.

Схему компиляции в деревья решений также несложно модифицировать для поддержки оператора возврата. Более того в действительности, многие компиляторы, такие как компилятор языка Rust~\cite{rust_reference}, уже используют инструкции безусловного перехода для компиляции охранных выражений: охранные выражения компилируются внутри тела ветви, а для случая не допуска генерируется переход на сопоставление следующей ветви. Аналогичные действия предпринимаются и в компиляторе языка OCaml.

Проверку на полноту можно расширить следующим образом: для ветви, в теле которой есть команда \lstinline|backtrack|, относящаяся к сопоставлению этой ветви или вышестоящему, в конец строки образцов добавляется образец на целочисленную константу 42. А в конец вектора значений неявно добавляется некоторое фиктивное значение 0. Такие действия мотивированы тем, что сопоставления с целочисленной константой всегда неполно, поскольку сигнатура типа \lstinline|int| считается бесконечной. А это ровно та ситуация, которая нам требуется --- для ветвей, содержащих \lstinline|backtrack|, заставить механизм предупреждений \cite{maranget2007warnings} обрабатывать эту ветвь, как если бы для нее существовали значения, не проходящие успешного сопоставления. Можно показать, что при таком подходе, остальные проверки вроде избыточности (redundancy) также будут обладать желаемой семантикой.

Напоследок сделаем замечание о практической применимости: как будет далее показано в разделе \ref{sec:final_choice} оператор возврата к сопоставлению с теоретической точки зрения обладает максимально-возможной гибкостью. При этом такой оператор крайне эффективно компилируется. В действительности необходимость в таких конструкциях возникает довольно редко, но если все-таки возникает, как правило, иного способа, кроме как изменить высокоуровневую структуру кода, не остается, что может быть в свою очередь менее эффективно по производительности.

С другой стороны, оператор возврата является низкоуровневой конструкцией, противоречащей духу ML-языков, к тому же его использование как правило синтаксически довольно тяжеловесно, что впрочем можно улучшить введением синтаксического сахара, наподобие конструкции \lstinline[language=none]|if-let|~\cite{ocaml_iflet} или тех же обобщенных охранных выражений, которые очевидным образом транслируются в операторы возврата.

Язык OCaml стремится достигать баланса между академичностью и производительным решением практических задач, а посему почти бесплатная (во всех отношениях) конструкция \lstinline|backtrack| может считаться оправданной для последней категории.

\section{Выбор конструкции для реализации} \label{sec:match_ext}

\subsection{Введение объективных критериев для сравнения} \label{sec:criteria_introduction}

Для выбора конкретного дизайна необходимо научиться объективно сравнивать существующие решения, для чего в свою очередь необходимо ввести некоторые критерии. К настоящему моменту таких критериев не было сформулировано: существующие решения сравнивались на некоторых отдельных группах примерах, оперируя такими субъективным понятиями как "краткость синтаксиса", "расширяемость", "легковесность", "более общее" и~т.п.

Для введения подходящих критериев стоит обратиться к теоретической части задачи. Что такое "образец"? Что такое "сопоставление с образцом"? Что такое "конструкция сопоставления с образцом"? Какие теоретические задачи они призваны решать? Опять-таки в существующих работах подобные понятия определяются специфично для конкретного языка: вводятся некоторые синтаксические конструкции, наделяются определенной семантикой, и их называют уже перечисленными выше терминами. Поскольку сами определения как правило привязаны к конкретному языку, сравнивать конструкции между языками становится достаточно сложно. 

М.~Туллсен~\cite{tullsen2000firstclass} первым указал на данную проблему и сосредоточился на теоретической части. Введенные им определения не зависят от конкретного языка и применимы к любому статически типизированному языку с функциями высших порядков и алгебраическими типами данных. 

Так \textit{образец} определяется как произвольная функция типа \linebreak \lstinline|$\tau$ $\to$ Maybe $\zeta$|, \textit{сопоставление с образцом} определяется как применение данной функции к значению и декомпозиции результата (который ограничен типом \lstinline|Maybe $\zeta$|). 

Для формирования образцов вводится некоторое множество \textit{комбинаторов образцов} (определения и семантика которых подробно описаны в оригинальной работе), позволяющих определять составные образцы из более простых:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=ocaml, escapechar=@]
type ('a, 'b) pat = 'a -> 'b option

(*@ Комбинатор ИЛИ @*)
val (@\$@|): ('a, 'b) pat -> ('a, 'b) pat -> ('a, 'b) pat
(*@ Комбинатор И @*)
val (@\$@&): ('a, 'b) pat -> ('a, 'b) pat 
                       -> ('a, 'b * 'b) pat
(*@ Комбинатор композиции @*)
val (@\$@:): ('a, 'b) pat -> ('b, 'c) pat -> ('a, 'c) pat
(*@ Комбинатор функтор-отображения @*)
val (@\$@>): ('a, 'b) pat -> ('b -> 'c)   -> ('a, 'c) pat
(*@ Комбинатор параллельного разбора @*)
val (@\$@*): ('a, 'c) pat -> ('b, 'd) pat 
                       -> ('a * 'c, 'b * 'd) pat
\end{lstlisting}
\end{minipage}

Заметим, что исходя из самого определения образцы являются значениями первого порядка, могут применяться для значений абстрактных типов, а семантика образцом (и комбинаторов) может быть определена произвольным образом на уровне самого языка. Таким образом, данное теоретическое определение покрывает все известные практически случаи использования образцов.

Наконец, представляется естественным определить \textit{конструкцию сопоставления с образцом}, как встроенный язык описания предметной области (Embedded DSL), предоставляемый хост-языком для определения образцов. Заметим, что существующие языки используют данную конструкцию одновременно и для применения сопоставления с определяемым образцом. 

Благодаря такому определению мы естественным образом получаем критерий для сравнения "мощности" различных дизайнов конструкций сопоставления:

\begin{definition}[Максимальность]
Назовем конструкцию сопоставления с образцом \textbf{максимальной}, если она позволяет выразить произвольную композицию комбинаторов образцов.
\end{definition}

Также интересным представляется формализовать свойство синтаксической краткости или выразительности:

\begin{definition}[Выразительность]
Назовем конструкцию сопоставления с образцом \textbf{выразительной}, если при определении произвольного образца не требуется дублирования синтаксически одинаковых образцов, за исключением, быть может, идентификаторов-привязок.
\end{definition}

Заметим, что для такого критерия его невыполнимость проверяется простым приведением контрпримера, а вот его выполнимость это формально технически сложное доказательство.

Крайне важно отметить, что \textit{полнота сопоставления} еще формально не определена. Формально "полнота" это свойство именно образца, однако по исторически причинам прижился термин "полнота сопоставления". Кажется естественным определить образец полным, если при сопоставлении с ним могут быть получены только "непустые" значения, т.е. по М.~Туллсену, все результирующие значения имеют тег \lstinline|Just|. Несложно показать, что такое свойство \textit{неразрешимо}. Тотальные активные образцы F\# предлагают некоторое решение этой проблемы, позволяя в качестве образцов использовать также значения типа \lstinline|$\alpha$ ->  $\xi$|, где $\xi$ произвольный анонимный тип-сумма. В такой трактовке сопоставление с такими образцами всегда будет выдавать только "полезное" значение. Резюмируя, при достаточно мощной конструкции сопоставления в языке проверка на полноту в базовом определении неразрешима. Однако, ослабив определение образцов, можно выделить разрешимую группу полных \textit{по определению} образцов, добившись некоторой достаточной для по крайней мере некоторых практических задач аппроксимации полноты.


\subsection{Сравнение существующих решений}

Произведем сравнение различных дизайнов по следующему ряду критериев:
\begin{itemize}
\item \textit{максимальность}, введенная в предыдущем разделе, отражает практическую способность расширения решать поставленный круг \mbox{задач};
\item \textit{выразительность}, введенная в предыдущем разделе, отражает синтаксические затраты на реализацию задачи;
\item \textit{свойство языка представлять образцы как значения первого \mbox{класса}} (заметим, что исходя из данного нами определения, это, к сожалению, не следует из свойства максимальности);
\item \textit{проверка на полноту}, как уже было сказана, неразрешима, тем не менее нас интересует по крайней мере наличие у расширения формальных аппроксимаций;
\item \textit{эффективность} --- поскольку конструкция сопоставления с образцом является центральной для функциональных языков к ним предписываются жесткие требования по эффективной компиляции. Здесь нас интересуют наличие в литературе модификаций для эффективных схем компиляции, таких как \cite{fessant2001optimizing, maranget2008decisiontrees, scott2000whendo}.
\end{itemize}

Результаты представлены в таблице \ref{tab:comparison}.

\begin{table}[H]
\centering
\begin{tabular}{l|c|c|c|c|c}
Дизайн               & Макс-ть        & Выр-ть     & 1п.          & Проверя-ть      & Эффект-ть      \\ \hline
Views                & \textbf{---}   & \textbf{---} & \textbf{---} & \textbf{+}      & \textbf{?}     \\
Views for SML        & \textbf{---}   & \textbf{---} & \textbf{---} & \textbf{+}      & \textbf{+}     \\
Pattern guards       & \textbf{+}     & \textbf{---} & \textbf{+}   & \textbf{+}      & \textbf{?}     \\
First class patterns & \textbf{+}     & \textbf{+}   & \textbf{+}   & \textbf{+/---}     & \textbf{---}  \\
View patterns        & \textbf{+}     & \textbf{---} & \textbf{+}   & \textbf{+}      & \textbf{?}     \\
Objects patterns     & \textbf{---}   & \textbf{---} & \textbf{+}   & \textbf{?}     & \textbf{?}     \\
Active Patterns      & \textbf{+/---}  & \textbf{---} & \textbf{+}   & \textbf{+}      & \textbf{+}     \\
Pattern Synonyms     & \textbf{---}   & \textbf{---} & \textbf{?}   & \textbf{+}      & \textbf{?}     \\
Оператор возврата    & \textbf{+}     & \textbf{+/---} & \textbf{+}  & \textbf{+}      & \textbf{+}     \\
\end{tabular}
\caption{\label{tab:comparison} Сравнение конструкций сопоставления}
\end{table}

Приведем краткие доказательства и замечания по каждому из \mbox{пунктов}.

\subsubsection{Максимальность}

Все отрицательные значения в столбцах возникают по причине, что соответствующие расширения не предоставляют возможности параметризовать часть образца значением (представления, представления SML, образцы представленные объектами и синонимы образцов), в частности значение, полученным привязкой другого образца (активные образцы). Можно рассмотреть следующий синтетический пример из \cite{viewshaskell}:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=haskell, escapechar=@]
example :: ((String->Integer,Integer),String)->Bool
example ((f,_), f -> 4) = True
\end{lstlisting}
\end{minipage}

Здесь значение \lstinline|f|, привязанное в одной части образца, используется в другой (в данном случае само значение представляет собой view образец). Такое достаточно важное свойство (которое мы будет называть \textit{параметризацией слева-направо} (left-to-right parameterization)) поддерживается только дизайнами представляющих образцов (view patterns) и обобщенных охранных выражений (pattern guards). Однако отметим, что активные образцы также очевидным образом могут поддержать данную семантику, несмотря на то, что реализация языка F\# не предлагает такой возможности. Такая дополнительная возможность никоим образом не влияет на проверку на полноту и мемоизацию~\cite{okasaki98views}. Единственный объективный недостаток такой возможности заключается в том, что для схем компиляции в деревья решений мы получим очевидное ограничение на порядок столбцов, что впрочем с практической точки зрения вряд ли можно назвать существенным.

\subsubsection{Выразительность}

Согласно таблице критерий выразительности в текущей его формулировке оказалось совершенно нерепрезентативен --- при любом расширении так или иначе существует пример, требующий дублирования кода.

Для всех расширений можно привести следующий синтетический пример дублирования, возникающий при использования комбинатора композиции и комбинатора ИЛИ.

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=ocaml, escapechar=@]
type t = C1
       | C2
       | C3
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=ocaml]
let _ =
  match[@label outer] a, b with
  | _, b ->
     begin match b with
     | C1 -> 1
     | C2 -> 2
     | C3 -> backtrack%outer
     end
  | C2, C3 -> 3
  | _      -> 4
\end{lstlisting}
\end{minipage}

Данный пример записан с помощью использования оператора возврата к сопоставлению, однако при попытке переписать его средствами других расширений мы неизбежно получим дублирование одного из образцов (которые в общем случае могут быть произвольно сложными). 

Идея такого сопоставления заключается в том, что внутри одной ветви мы можем разбирать какую-то часть данных, но при определенных обстоятельствах иметь возможность вернуться к общему сопоставлению и продолжать разбирать его в надежде, что найдется некоторая другая комбинация образцов, под которую попадут данные. 

Несмотря на некоторую кажущуюся искусственность ситуации такой шаблон в действительности возникал при написании промышленного ПО. В качестве примера, мы можем привести код на языке Scala \cite{unexpresiveness_example}, преобразующий язык из одного представления в другое. При этом существует некоторое ограниченное множество исключительных ситуаций, которые по тем или иным причинам необходимо обработать особым образом. Множество ситуаций представлено одним большим сопоставлением, при этом каждая часть конструкции также имеет смысл быть разобранной с помощью вложенного сопоставления с возможностью возврата к внешнему, что в языке Scala невыразимо в виду отсутствия оператора возврата.

Оператор возврата же в действительности не имеет этой проблемы и формально даже является выразительным расширением, однако этот дизайн также нельзя назвать таковым с практической точки зрения ввиду огромного синтаксического шума ключевых слов при попытке использования образцов над абстрактными типами данных, а также вырождения сопоставлений в последовательность и невозможности использования привычного структурного вложения образцов:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=ocaml, escapechar=@]
let rec destutter2 l = 
  match head l with
  | Some(hd, tl) ->
      begin match head tl with
      | Some(hd', _) when hd = hd' -> destutter tl
      | _ -> cons hd (destutter tl)
      end
  | None -> nil
\end{lstlisting}
\end{minipage}

Сравните данную реализацию с предложенной в разделе \ref{sec:active_patterns} на основе активных образцов.

Таким образом решение данной проблемы состоит в том, чтобы совместить дизайны предоставляющие возможность возвратов (такие как pattern guards или оператор возврата) и дизайны предоставляющие абстракции на уровне структурного вложения (такие как view patterns и активные образцы). Можно заключить, что текущая экосистема Haskell, обладающая как pattern guards, так и view patterns наиболее близка к оптимальности по выразительности и не достигает ее лишь потому, что, как уже упоминалось в разделе \ref{sec:generalized_backtracking} pattern guards не позволяют разбирать несколько альтернатив внутри ветви.

\subsubsection{Образцы первого класса}

Выполнение или невыполнение данного свойства напрямую следует из определения каждого дизайна. Особенный случай здесь представляют лишь синонимы образцов, для которых кажется очевидным возможность использования их в качестве значений первого класса, но конкретной реализации пока не предоставлено --- данный вопрос оставлен открытым и в самой работе \cite{pickering2016pattern}.

\subsubsection{Проверка на полноту}

Как уже было отмечено, проверка на полноту в строгом смысле неразрешима, однако для каждого из расширений представлены достаточно точные аппроксимации. Впрочем точность, сложность реализации и производительность этих проверок довольно сильно варьируются от дизайна к дизайну. Скажем, для активных образцов и представлений SML такая проверка может быть реализована достаточно просто и эффективно \cite{maranget2007warnings}, но вот для множества расширений языка Haskell проверка весьма затруднительна и лишь недавно \cite{peytonjones2020lower} был предложен сложный комплекс алгоритмов, использующих к примеру SMT-решатели для повышения точности выдаваемых предупреждений.  

Напомним, что для образцов первого порядка М.~Туллсена, как уже упоминалось в \ref{sec:criteria_introduction}, разумной аппроксимации можно добиться, только расширив их определение.

Для образцов представляемых объектами \cite{emir2007objects} ситуация с проверкой на полноту, как упоминалось ранее в \ref{sec:scala_objects}, довольно сложна. Более того семантика языка Scala предписывает вызов функции-экстрактора на каждое сопоставление, не используя мемоизацию, и дозволяет использование эффектов, что, как описано в \cite{okasaki98views}, кратно усложняет определения полноты и избыточности ветвей. Вопрос, какой аппроксимации можно добиться при таком дизайне остается открытым.

\subsubsection{Эффективность}

Эффективная компиляция сопоставлений над абстрактными типами данных это малоизученная и открытая область для исследований. Для активных образцов (а равно и для представлений SML, выразимых через них) в оригинальной работе \cite{syme2007extensible} представлена компиляция в деревья решений \cite{scott2000whendo}, и авторы утверждают, что можно добиться лучших результатов, используя дополнительные возможности платформы, такие как кортежи, передаваемые на стеке (unboxed tuples). Также открытым остается вопрос, какие из расширенного ряда оптимизаций, представленных в \cite{maranget2008decisiontrees}, применимы для активных образцов. Для комплекса расширений языка Haskell неизвестно публикаций, раскрывающих вопросы оптимальной компиляции. Необходимо также учитывать различия стратегий вычисления и виды разрешенных алгебраических эффектов, используемых в языках, что еще более усложняет объективные сравнения.

Необходимо также сделать небольшое замечание касаемо образцов первого порядка М.~Туллсена. Несмотря на то, что они представляют образцовую теоретическую модель, с практической точки зрения такая технология совершенно неприменима. Заметим, что создание образцов происходит во время исполнения (что, с одной стороны, повышает теоретическую гибкость), а сопоставление с ними вычисляется строго в соответствии с тем, как они были сконструированы, что не допускает \textit{логических} оптимизаций. Наконец, сопоставление с образцами активно использует вызовы функций, что в общем случае не допускает \textit{физических} оптимизаций. 

Для решения этих проблем можно предложить два подхода:
\begin{itemize}
\item Использование \textit{динамического компилятора}, который мог бы специальным образом обрабатывать такие конструкции и специализировать их непосредственно по время исполнения. Это позволит добиться максимально-производительных результатов с сохранением абстракций времени компиляции, однако реализация динамического компилятора является крайне сложной технической задачей.
\item Введение в хост-язык специального языка описания предметной области (DSL) для формирования сопоставлений с образцом и выделение некоторого подмножества образцов, которые могут быть скомпилировано эффективно. Это значительно упростит задачу компилятору по применению специальных оптимизаций и позволит представлять сопоставления более декларативно для пользователей. Тем не менее при активном использовании абстракций и раздельной компиляции, разумеется, компилятор не сможет применять большинство оптимизаций, и машинный код выродится в аналогичный порождаемому при использовании образцов первого порядка. Поэтому по-прежнему для генерации максимально эффективного кода необходимо использовать либо встраивание времени линковки (LTO), либо более общее динамическое встраивание времени исполнения (динамическая компиляция).
\end{itemize}

\subsection{Заключительный выбор} \label{sec:final_choice}

Наконец, можно произвести окончательный, объективный насколько возможно выбор расширения для реализации. 

Согласно данным таблицы \ref{tab:comparison} наиболее привлекательным для реализации представляется оператор возврата. Просто удивительно, насколько самое тривиальнейшее решение оказывается самым технически мощным! Вполне в духе языка программирования C.

Тем не менее предлагается все-таки реализовать активные образцы с поддержкой \textit{параметризации слева-направо}, поскольку они являются своего рода синтаксическим сахаром для оператора возврата (поддерживают структурное вложение образцов) и автоматически реализовывают мемоизирующую семантику, а посему могут быть дополнительно оптимизированы компилятором. Оператор возврата является в этом смысле максимально гибким, но все же низкоуровневым инструментом, который также рекомендуется для поддержания языками ввиду своей тривиальности.

Важно отметить, что в рамках данной работы, мы не учитывали критерии совместимости расширений с продвинутыми особенностями системы типов, такими как, например, обобщенные алгебраические типы данных (GADT). Такие возможности на данный момент поддерживаются только синонимами образцов. Для активных образцов авторы также предлагали возможное развитие в области GADTS и экзистенциальных типов данных, однако этот вопрос по-прежнему остается открытым. 

\section{Реализация активных образцов в OCaml}

В данном разделе мы представим формализацию выбранного к реализации расширения активных образцов в контексте языка OCaml.

\subsection{Расширение синтаксиса}

Для представления синтаксиса мы воспользуемся грамматикой из~\cite{leroy2019manual}. Необходимые модификации для внедрения структурированных имен следующие:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=C,escapechar=@] 
structured-name @\textbf{::=}@
       #@ Однозначный полный образец@
    '(|' capitalized-ident '|)'
       #@ Многозначный полный образец@
  | '(|' capitalized-ident {'|'capitalized-ident}'|)'}
       #@ Однозначный частичный образец@
  | '(|' capitalized-ident '|' '_' '|)'

value-name @\textbf{::=}@ ... 
  | structured-name 
\end{lstlisting}
\end{minipage}

Необходимые модификации синтаксиса образцов следующие:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=C,escapechar=@] 
pattern @\textbf{::=}@ ...
        #@ Параметризованный частичный образец@
  | '<' capitalized-ident expr {expr} '>' pattern
\end{lstlisting}
\end{minipage}

Полные и не параметризованные частичные образцы уже представляются синтаксисом конструкторов-образцом. Это является желательным свойством, дабы публичное определение типа можно было бы скрыть, заменив его на экспортированный активный образец, что не потребовало бы  синтаксических вмешательств в сопоставления, использующих конструкторы этого типа (однако перекомпиляция все равно потребуется во имя производительности).

Таким образом, необходимо лишь ввести дополнительный синтаксис для параметризованных частичных образцов. Заметьте, что здесь мы отходим от синтаксиса, представленного в оригинальной работе: образец вместе с параметрами должен быть заключен в угловые скобки. Причина этому следующая: синтаксически категории выражений и образцов значительно пересекаются и LALR(1)-парсер не сможет понять, стоит ли перед ним еще один параметр-выражение, либо уже образец: к примеру, является ли \lstinline|Pat 42| частичным образцом с параметром 42, после которого последует что-то еще, либо образцом-конструктором, тело которого сопоставляется с константой 42? У этой проблемы есть 2 возможных решения:

\begin{enumerate}
\item Либо мы хотим все же различать в общем случае выражения и образцы, для чего область выражений необходимо заключить в некоторые обрамляющие символы (в нашем случае угловые скобки), дабы сгенерированный автомат знал, что пока не будет встречена закрывающая угловая скобка, следуют только выражения.
\item Либо мы синтаксически ограничиваем возможные выражения до уровня образцов, и все разбираем как образцы, а затем, на последующих фазах компиляции, преобразовываем часть результатов в категории выражений. Это подход принятый в F\# и позволяющий избежать необходимости использования обрамляющих символов. Однако такой код тяжело читать и человеку, поскольку образцы и параметры вне контекста неотличимы. И ощущается довольно странным, что в качестве параметров частичного образца нельзя передавать то, что можно передавать в качестве аргументов вызова функции, например лямбды или элемент массива по индексу.
\end{enumerate}

\subsection{Правила типизации}

К сожалению, для языка OCaml статическая семантика в литературе не представлена. Поэтому добиться математической строгости в рамках данной работы априори не получится, ввиду того, что строгость требует введения большого количества инструментов и определений. По этим, а также по другим причинам, описанным в исходной работе~\cite{syme2007extensible}, единственным способом для презентации правил типизации является представление эталонного типизирующего анализатора, производящего типизированное абстрактное синтаксическое дерево для исходного кода. 

Такой анализатор является частью прототипа, реализованного в рамках данной работы и представлен в~\cite{myrepo}.

\subsection{Модификация схемы компиляции}

В данном разделе мы представим необходимые модификации для оптимизированной схемы компиляции в автоматы поиска с возвратами \cite{fessant2001optimizing}.

Напомним, что для поддержания необходимых теоретических свойств активным образцам предписывается мемоизирующая семантика \cite{okasaki98views}: для каждого вхождения активного образца, соответствующая ему трансформирующая функция вызывается не более одного раза. Таким образом, необходимо для начала выписать все вхождения активных образцов, а затем для каждого из них выделить переменные для сохранения результатов вызова.

\textit{Вхождения} (occurences) мы определяем формально в соответствии с работой~\cite{maranget2008decisiontrees}: вхождение $o$ есть либо пустой вектор $\Lambda$, либо число $k$, за которым следует вхождение $o'$: $k \cdot o'$. Вхождения задают пути к подтермам терма $v$ в следующем смысле:
\begin{align*}
	v/\Lambda &= v  \\
	c(v_1,\ldots, v_n)/k \boldsymbol{\cdot} o &= v_k/o  
\end{align*}

Теперь необходимо дополнить схему $C^*$ двумя параметрами --- вхождением $o$, которое призвано отслеживать, с какой частью входного выражения сейчас производится сопоставление и \textit{кэш-картой} $amap$. Обновленная кэш-карта также будет возвращаться схемой в качестве третьего элемента, в дополнение к сгенерированному коду и таблице контекстов.

Вхождение изменяется естественным образом: 

\begin{itemize}
\item Для правил схемы компиляцией, выполняющих специализацию (таких как правило конструктора (constructor-rule)), выполняемые рекурсивные вызовы должны получать специализацию вхождения по конструктору (такая операция формально описана в работе~\cite{maranget2008decisiontrees}).
\item Для рекурсивного вызова правила переменных (variable-rule), вхождение инкрементируется.
\item Для компиляции матрицы $P'' \to L''$ правила или-образцов (orpat-rule)~\cite{fessant2001optimizing} вхождение также инкрементируется.
\item В разделяющем правиле вхождение передается рекурсивным вызовам неизменным.
\end{itemize}

Кэш-карта образцов представляет собой отображение из вхождений в список пар идентификаторов активных образцов и сгенерированных имен кэш-переменных. Для одного вхождения могут быть вызваны несколько независимых активных образцов, для каждого из которых потребуется выделить свой кэш. В качестве примера рассмотрим следующее сопоставление:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=OCaml,escapechar=@] 
let (|M1|M2|) x = (* ... *)
let (|C|_|)   x = (* ... *) 
let (|D|_|)   x = (* ... *) 

let _ =
  match (1, 2, 3) with
  | (M1 _, C _, 42) -> 1
  | (M2 _, D _,  x) -> 2
  | (C  _, _  ,  _) -> 3
\end{lstlisting}
\end{minipage}

Сгенерированная кэш-карта будет следующей:
\begin{alignat*}{2}
\{ &1 \boldsymbol{\cdot}\ \mapsto [\ &((|M1|M2|)&,\ z1),\ ((|C|\_|),\ z2)\ ];\\ 
   &2 \boldsymbol{\cdot}\ \mapsto [\ &((|C|\_|)&,\ z3),\ ((|D|\_|),\ z4)\ ] \}
\end{alignat*}

Здесь теги \lstinline|M1| и \lstinline|M2| принадлежат одному и тому же активному образцу, а теги \lstinline|C| и \lstinline|D| разным. По третьей координате вектора входных значений сопоставления с активными образцами не проводится.

Наконец перейдем к описанию изменений в схему компиляции.

Для разделяющего правила (mixture-rule) для случая активных образцов мы будем жадно отбирать наибольший строчный префикс матрицы, в первой позиции образцов которой стоят теги, принадлежащие одному и тому же активному образцу. Так, для примера выше, в одному группу компиляции попадут первые 2 строки.

Компиляцию двух частей необходимо дополнить правильной передачей кэш-карты, что впрочем тривиально. Разделив матрицу $P \to L$ на подматрицы $Q \to M$ и $R \to N$, необходимо выполнить следующие рекурсивные вызовы:
\begin{alignat*}{3}
l_q, \rho_q, amap_q &= C^*(\vec{x}, Q \to M, partial &&, (R, e); &&def, ctx, o, amap) \\
l_r, \rho_r, amap_r &= C^*(\vec{x}, R \to N, ex &&, &&def, ctx, o, amap_q)
\end{alignat*}

Кэш-картой, возвращаемой всем правилом, является $amap_r$.

Теперь необходимо добавить новое правило компиляции группы строк с активными образцами. Рассмотрим лишь случай единичного полного активного образца, для остальных видов образцов необходимые действия абсолютно аналогичны, за исключением технических деталей, таких как вычисление параметров для параметризованных образцов и сопоставление результата преобразования с тэгами анонимного типа-суммы для многозначных полных образцов.

Входная матрица $P \to L$ имеет вид $(A(q_1,\ldots,q_a)\ p_2\ \cdots\ p_n \to l)$ и активный образец \lstinline{(|A|)} является единичным полным. В этом случае требуется всего лишь вызвать соответствующую преобразующую функцию. Выполнив рекурсивный вызов, получим:
\begin{alignat*}{1}
l_c, \rho, amap = \\
C^*(&(y_1\ \cdots\ y_a\ x_2\ \cdots\ x_n), (q_1\ \cdots\ q_a\ p_2 \cdots p_n \to l),\\
&ex, \Downarrow(def), \Downarrow(ctx), o\cdot0, amap)
\end{alignat*}

Если $amap(o)$ уже содержит $(|A|)$ в качестве ключа, то достаем имя переменной кэша $z$. В этом случае вызов $(|A|)$ уже состоялся ранее и можно просто пользоваться значением $z$. Результирующий код $l_r$ будет следующим: 

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=lambda,escapechar=@] 
(let (y1 (field 0     z))
       ...
     (ya (field (a-1) z))
     @$l_c$@))
\end{lstlisting}
\end{minipage}

Если $amap(o)$ не содержит $(|A|)$ в качестве ключа, то генерируем свежее имя переменной кэша $z$ и положим $amap(o)\ += ((|A|),z)$. В этом случае $l_r$ выше необходимо будет обернуть в вызов преобразующей функции:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=lambda,escapechar=@] 
(seq (setfield 0 z (apply (|A|) x1)) @$l_r$@)
\end{lstlisting}
\end{minipage}

Схема возвращает $l_r$, поднятое (popped) $\rho$ и $amap$ (с учетом добавления, если таковое произошло).

Наконец, осталось лишь для начального вызова компиляции сопоставления произвести генерацию необходимых переменных кэшей. Пусть имеем $l,\_,amap=C^*(\ldots)$, $(z_1, t_1),\ldots,(z_n, t_n)$ список пар всех выделенных переменных и их типов (выведенных из типов сохранённых идентификаторов активных образцов), тогда код $l$ необходимо обернуть в:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=lambda,escapechar=@] 
(let (z_1 = (makemutable 0 (t_1) 0))
       ...
     (z_n = (makemutable 0 (t_n) 0))
     @$l$@)
\end{lstlisting}
\end{minipage}

Внимательный читатель заметит, что в общем случае сгенерированных переменных может быть довольно большое количество. Т.к. они выделяются на стеке на производительности это особо не сказывается, но вот для не хвосто-рекурсивных функций такое дополнительное потребление памяти может оказаться весьма критичным. В общем случае некоторые переменные можно пытаться переиспользовать, однако оставим это за рамками текущей работы.

\section{Заключение}

\noindent В данной работе были достигнуты следующие результаты:

\begin{enumerate}
  \item Произведён подробный разбор аналогов в большинстве наиболее передовых функциональных языков, выделены решения, которые могут служить опорой для дизайна расширений для языка OCaml:
  \begin{itemize}
      \item Представлено расширение оператора возврата к сопоставлению.
      \item Введены объективные критерии для сравнения существующих решений и произведен анализ каждого из расширений, представленных как кандидаты к реализации, обоснован выбор активных образцов как расширения для реализации.
      \item Инициирован RFC~\cite{myrfc} по реализации активных образцов в качестве расширения языка OCaml; текущие наработки по реализации должны послужить в качестве образца синтаксиса и семантики для RFC.
  \end{itemize}
  \item Формализованы следующие изменения, необходимые к внесению в компилятор языках OCaml для поддержки активных образцов:
  \begin{itemize}
    \item расширение синтаксиса
    \item правила типизации новых конструкций
    \item модификация схемы компиляции~\cite{fessant2001optimizing} для активных образцов
  \end{itemize}
  \item Реализованы следующие элементы прототипа расширения:
  \begin{itemize}
    \item синтаксический анализ
    \item типизация
  \end{itemize}

\end{enumerate}

\section{Благодарности}

Автор работы благодарит программиста ``JetBrains Labs'' Дмитрия \linebreak \mbox{Косарева} за всестороннюю консультацию и помощь в организации работы.

Также автор безмерно благодарен Олегу Киселёву за его бесценные статьи по внутреннему устройству компилятора OCaml~\cite{okmij_typechecker}, благодаря которым стало возможным разобраться в существующем коде типизации и провести его модификацию.

\bibliographystyle{ugost2008ls}
\renewcommand\refname{Список литературы}
%\bibliography{Bashkirov/main.bib}
\input{Bashkirov/bibliography.tex}
