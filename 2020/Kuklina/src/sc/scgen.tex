%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Описание общего алгоритма суперкомпиляции
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% На основе введёных выше терминов и операторов можно составить обобщённый алгоритм
% суперкомпиляции, который не затрагивает особенности и трудности реализации на Haskell.
% % Однако прежде необходимо ввести ряд необходимых понятий.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %% Описание окружения
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %
% %\emph{Окружение} для суперкомпиляции должно сохранять следующие объекты:
% %\begin{itemize}
% %\item подстановку, в которой содержатся все накопленные непротиворечивые унификации,
% %      необходимую в процессе прогонки для проверки новых унификаций;
% %\item первую свободную семантическую переменную, необходимую для генерации свежих переменных,
% %      к примеру, при абстракции;
% %\item определение программы, необходимое для замены вызова на своё тело.
% %\end{itemize}
% % 
% % \todo{Что-то ещё об этом нужно написать!}

% Обобщённый алгоритм суперкомпиляции в псевдокоде представлен на рисунке~\ref{fig:scalgogen}.

% \begin{figure}[h!]
% % обобщение вверх
% % else if $\exists$ parent: parent $\genup$ configuration
% % then
% %    node $\larrow$ generalize(configuration, parent)
% %    addUp(env, tree, parent, node)

% \begin{lstlisting}[escapechar=@]
% supercomp(program, query):
%   env $\larrow$ createEnv program
%   configuration $\larrow$ initialize query
%   graph $\larrow$ emptyTree
%   drive(env, graph, configuration)
%   return residualize graph

% drive(env, graph, configuration):
%   if configuration is empty  @\label{line:success}@
%   then add(env, graph, success node)
%   else if $\exists$ parent: configuration $\variant$ parent @\label{line:renaming}@
%   then add(env, graph, renaming node)
%   else if $\exists$ parent: parent $\embed^+$ configuration @\label{line:abstraction}@
%   then
%     add(env, graph, abstraction node)
%     children $\larrow$ generalize(configuration, parent) @\label{line:gen}@
%     $\forall \text{child} \in \text{children}:$
%       drive(env, graph, child)
%   else @\label{line:unfolding}@
%     add(env, graph, unfolding node)
%     children $\larrow$ unfold(env, configuration) @\label{line:unfold}@
%     $\forall \text{child} \in \text{children}:$
%       drive(env, graph, child)
% \end{lstlisting}
% \caption{Обобщённый алгоритм суперкомпиляции.}
% \label{fig:scalgogen}
% \end{figure}

% Алгоритм суперкомпиляции принимает на себя программу и запрос,
% на который необходимо специализировать программу, и после
% инициализации начальных значений, включающих в себя некоторое \emph{окружения программы},
% в котором хранятся все вспомогательные структуры, запускает процесс прогонки.
% Прогонка производится до схождения и производит следующие действия в
% зависимости от состояния:
% \begin{itemize}
% \item если конфигурация пустая (строка~\ref{line:success}), это означает, что вычисления
%       успешно сошлись в конкретную подстановку. В таком случае происходит добавление
%       в граф листового узла с этой подстановкой;
% \item если существует такая родительская конфигурация, что она является вариантом текущей (строка~\ref{line:renaming}),
%       то происходит свёртка и в граф добавляется листовой узел с ссылкой на родителя;
% \item если же среди родителей находится такой, на котором срабатывает свисток (строка~\ref{line:abstraction}),
%       тогда производится обобщение, порождающее дочерние конфигурации (строка~\ref{line:gen}),
%       на которых продолжается процесс прогонки;
% \item иначе происходит шаг символьного вычисления (строка~\ref{line:unfolding}), на котором
%       порождаются конфигурации.

% \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Описание шага unfolding'а
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Стратегия символьного вычисления определяется функцией \lstinline{unfold}
(строка~\ref{line:unfold}), что означает ``развёртывание'' по определеням вызовы реляционных отношений.
Развёртка по данной конфигурации $C$ порождает
множество конфигурации $\{ C_1, \dots, C_n \}$, описывающих состояния в которое может перейти
процесс реального исполнения программы. Классически, шаг символьного
вычисления соответствует семантике языка, который суперкомпилируется,
и для \ukanren существует сертифицированная семантика\cite{semanticMK},
однако описание шага символьного вычисления \ukanren для суперкомпиляции 
усложнено тем, что реляционные языки не исполняются привычным образом,
как, к примеру, функциональные программы, и \emph{поиск}, вшитый в семантику,
не ложится на суперкомпиляцию прямым образом.

Тогда порождённую конфигурацию можно рассматривать не как непосредственный
шаг вычисления, но как возможное состояние, в которое может перейти программа.
Такое состояние появляется путём раскрытия тела одного или нескольких
конъюнктов конфигурации.

К примеру, рассмотрим часть программы на \ukanren на рисунке~\ref{fig:unfoldEx}, в котором
определены какие-то отношения \lstinline{f} и \lstinline{g}.
\begin{figure}[h!]
\begin{lstlisting}
f(a) = f'(a)$\lor$f''(a)
g(a, b) = g'(a)$\land$g''(b)
\end{lstlisting}
\caption{Пример отношений для демонстрации шага символьных вычислений}
\label{fig:unfoldEx}
\end{figure}

Допустим, на шаге суперкомпиляции алгоритм обрабатывает конфигурацию
\lstinline{f($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$, $\text{v}_\text{2}$)}
хотим сделать шаг символьного вычисления. Рассмотрим несколько способов породить новые конфигурации.
\begin{itemize}
\item Если раскроется определение \lstinline{f}, то будут получены новые конфигурации 
      \lstinline{f'($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$, $\text{v}_\text{2}$)} и
      \lstinline{f''($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$, $\text{v}_\text{2}$)}.
\item Если раскроется определение \lstinline{g}, то будет получена новая конфигурация 
      \lstinline{f($\text{v}_\text{1}$)$\land$g'($\text{v}_\text{1}$)$\land$g''($\text{v}_\text{2}$)}.
\item Если раскроются оба определения \lstinline{f} и \lstinline{g}, то будут получены новые конфигурации 
      \lstinline{f'($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$)$\land$g''($\text{v}_\text{2}$)} и
      \lstinline{f''($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$)$\land$g''($\text{v}_\text{2}$)}.
\end{itemize}

Последний набор конфигураций --- это полный набор состояний, в которые процесс вычислений может
прийти. В первых двух наборах, можно отметить, порождённые конфигурации не исключают
возможные состояния процессов, отображённые в последнем наборе, они могут появится на последующих шагах вычисления,
если перед этим ветвь исполнения не будет остановлена из-за противоречивой подстановки.

Таким образом, какой бы способ развёртывания определений ни был бы выбран, он не будет
исключать состояния, в которые процесс вычисления теоретически может прийти, но выбор
разных стратегий развёртывания может систематически приводить к разным деревьям процессов,
а следовательно --- к различным эффектам специализации.

\todo{Слова про терминируемость за счёт переиспользования алгоритма обобщения CPD и гомеоморфного вложения.}
