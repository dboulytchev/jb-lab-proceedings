Реализация суперкомпилятора для \ukanren строилась на основе проекта по специализации \ukanren с помощью конъюнктивной частичной
дедукции\footnote{Проект \url{https://github.com/kajigor/uKanren_transformations/}, дата последнего посещения: 10.05.2020} на функциональном языке программирования Haskell.
Результаты специализации \ukanren представлены в работе~\cite{lozov}.

Библиотека вводит ряд структур данных и алгоритмов для реализации конъюнктивной частичной дедукции,
однако существует возможность её переиспользования для суперкомпиляции в силу нескольких доводов:
\begin{itemize}
\item схожесть методов частичной дедукции и суперкомпиляции~\cite{pdAndDriving},
      из чего следует, что ряд вспомогательных функций и определений и для частичной дедукции, и для суперкомпиляции
      будут совпадать;
\item алгоритм обобщения конъюнктивной частичной дедукции~\cite{cpd}, о котором подробнее будет рассказано позже,
      имеет ряд общих черт с процессом обобщения в суперкомпиляции;
\item библиотека предоставляет возможность преобразования сгенерированной программы
      на miniKanren, при котором удаляются излишние унификации и
      происходит удаление лишних аргументов~\origin{redundant argument filtering}~\cite{raf},
      что приводит в увеличению производительности программы, поскольку унификация --- операция дорогая.
\end{itemize}

В библиотеке введены структуры данных, описывающие термы и выражения языка
в соответствии с синтаксисом \ukanren на рисунке~\ref{fig:syntax}.
Над ними введён ряд важных структур и алгоритмов, речь о которых пойдёт ниже.
Основные операции над выражениями в конъюнктивной частичной дедукции производятся над конъюнкциями
%\emph{атомов}, --- то есть неделимыми элементами, которыми в miniKanren являются
вызовов реляционных отношений.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Унификация
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Во-первых, в библиотеке реализован алгоритм унификации двух термов.
Операция унификации находит наиболее общий унификатор \origin{most general unifier},
причём единственный, то есть такой
унификатор $\theta$, что для любого другого унификатора $\theta'$ существует подстановка $\sigma$,
с которой композиция наиболее общего унификатора даёт $\theta'$: $\theta' = \sigma \circ \theta$~\cite{unification}.
К примеру, для двух термов $f(X, 2)$ и $f(1, Y)$ наиболее общим унификатором является
подстановка $\{ X \mapsto 1, Y \mapsto 2 \}$, когда подстановки вроде
$\{ X \mapsto 1, Y \mapsto Z, Z \mapsto 2 \}$ также унифицирует термы, однако
содержат в себе лишние элементы.
Поиск наиболее общего унификатора уменьшает размер итоговой подстановки и является предпочтительным.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Инстанс и вариант
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Во-вторых, реализованы предикаты над термами, которые проясняют описанные ниже возможные связи термов.
\begin{itemize}
\item Выражение $e_2$ является \emph{экземпляром} выражения $e_1$ ($e_1 \instance e_2$),
если существует такая подстановка $\theta$, применение которой приравнивает
два выражения $e_1 \theta = e_2$; также говорят, что $e_1$ более общий, чем $e_2$.
К примеру, $f(X, Y) \instance f(Y, X)$. %и $f(X, Y) \instance f(Y, X)$ .
\item Выражение $e_2$ является \emph{строгим} экземпляром выражения $e_1$ ($e_1 \strictinst e_2$), если
$e_1 \instance e_2$ и $e_2 \not\instance e_1$. К примеру, $f(X, X) \strictinst f(X, Y)$, но не наоборот.
\item Выражения $e_1$ и $e_2$ \emph{варианты} друг друга $e_1\variant e_2$, если они являются экземплярами друг друга.
\end{itemize}

Предикат над вариантами определяет, являются ли два терма переименованием друг друга,
и поэтому может быть использован для свёртки графа процессов. Предикаты над экземплярами определяют
схожесть термов и используется в обобщении и в алгоритмах суперкомпиляции~\cite{scPos}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Свисток и гомеоморфное вложение
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В-третьих, в качестве свистка используется отношение \emph{гомеоморфного вложения}~\cite{scGen}.
Отношение гомеоморфного вложения $\unlhd$ определено индуктивно:
\begin{itemize}
\item переменные вложены в переменные: $x \embed y$;
\item терм $X$ вложен в конструктор с именем $C$, если он вложен в один из аргументов конструктора:
      $$X \embed C_n(Y_1, \dots, Y_n): \exists i, X \embed Y_i;$$
\item конструкторы с одинаковыми именами состоят в отношении вложения, если в этом отношении
      состоят их аргументы:
      $$C_n(X_1, \dots, X_n) \embed C_n(Y_1, \dots, Y_n): \forall i, X_i \embed Y_i.$$
\end{itemize}

К примеру, выражение $c(b) \embed c(f(b))$, но $f(c(b)) \cancel{\embed} c(f(b))$.

Преимущество использования гомеоморфного вложения, в первую очередь, состоит в том,
что для этого отношения доказано, что на бесконечной последовательности выражений $e_0, e_1, \dots, e_n$
обязательно найдутся такие два индекса $i < j$, что $e_i \embed e_j$, вне зависимости
от того, каким образом последовательность выражений была получена~\cite{scPos}.
Это свойство позволяет доказать завершаемость алгоритма суперкомпиляции.

Однако отношение гомеоморфного вложения допускает, чтобы термы $f(X, X)$ и $f(X, Y)$
находились в отношении  $f(X, X) \embed f(X, Y)$ в силу того,
что все переменные вкладываются друг в друга. Однако обобщение
$f(X, X)$ и $f(X, Y)$ не привело бы к более общей конфигурации.

Отношение \emph{строгого} гомеоморфного вложения $\embed^+$ вводит дополнительное
требование, чтобы терм $X$, состоящий в отношении с $Y$, не был \emph{строгим экземпляром} $Y$~\cite{homeo}.
В таком случае отношение $f(X, X) \cancel{\embed}^+ f(X, Y)$, поскольку $f(X, Y)$ является строгим
экземпляром $f(X, X)$ из-за того, что существует подстановка $\{ X = X, Y = X \}$.

В рамках конъюнктивной частичной дедукции понятие гомеоморфного вложение было расширено на конъюнкции выражений.
Пусть $Q = A_1 \land \dots \land A_n$ и $Q'$ --- конъюнкции термов, тогда $Q \embed Q'$, тогда и только тогда,
когда $Q' \not\strictinst Q$ и существует упорядоченные подконъюнкции $A_1' \land \dots \land A_n'$
конъюнкции $Q'$, такие что $A_i \embed A_i'$~\cite{cpd}.
Конъюнкция $Q'$ может содержать в себе больше выражений за счёт того, что в этом случае при обобщении
произойдёт шаг разделения. Это расширение было реализовано в рассматриваемой библиотеке.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Обобщение
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


В-четвёртых, реализован алгоритм обобщения для конъюнктивной частичной дедукции.
В общем, алгоритмы обобщения основаны на понятии \emph{наиболее тесного обобщения}.
\begin{itemize}
\item \emph{Обобщение} выражения $e_1$ и $e_2$ --- это выражение $e_g$, такое что
$e_g \instance e_1$  и $e_g \instance e_2$. На пример, обобщением выражения
$f(1, Y)$ и $f(X, 2)$ является $f(X, Y)$.
\item Наиболее тесное обобщение \origin{most specific generalization}
выражений $e_1$ и $e_2$ --- это обобщение $e_g$, такое что
для каждого обобщения $e_g' \instance e_1$ и $e_g' \instance e_2$ выполняется $e_g' \instance e_g$~\cite{scPos}.
Функция обобщения принимает на себя два терма $t_1$ и $t_2$ и возвращает
тройку $(t_g, \theta_1, \theta_2)$, такую что $t_1 \theta_1 = t_g$ и $t_2 \theta_2 = t_g$,
при этом $\theta_1$ и $\theta_2$ назовём \emph{обобщающими унификаторами} \origin{generalizers}.
\end{itemize}

% Алгоритм обобщения для конъюнктивной частичной дедукции, в соответствии со своим
% определением гомеоморфного вложения, выберет предка $Q^p$ для конъюнкции $Q$,
% такого что $Q^p \embed^+ Q$, и
% \todo{понять, как это доступно описать.}
Алгоритм обобщения для конъюнктивной частичной дедукции согласован с
определением гомеоморфного вложения
и используется в рамках \forcpd для построения более сложных алгоритмов обобщения,
свойственных методам частичной дедукции.
Однако его можно использовать как самостоятельный алгоритм для
суперкомпиляции, который соединяет в себе возможность произвести шаги обобщения
и разделения вместе, не выделяя отдельные шаги для это в процессе прогонки.
