{\bf Суперкомпиляция} --- метод анализа и преобразования программ,
который отслеживает обобщённую возможную историю вычислений исходной
программы и строит на её основе эквивалентную ему, более оптимальную программу.
Впервые метод был предложен в работе~\cite{turchinSC}.

Упрощение достигается путём удаления или преобразования
некоторых избыточных действий: удаление лишнего кода, выполнение
операций над уже известными данными, избавление от промежуточных
структур данных, инлайнинг, превращение многопроходного алгоритма
в однопроходный и другие~\cite{scompRevisited}.
Также cуперкомпиляция может применяться для специализации программ.

% В конечном счёте, суперкомпилятор может придать программе линейное ускорение

Суперкомпиляция включает в себя частичные вычисления, однако не
сводится к ним полностью и может привести в глубоким структурным
изменениям оригинальной программы.

Суперкомпиляторы, которые используют только ``положительную''
информацию --- то есть информацию о том, что свободные переменные
чему-то равны, --- называют
позитивными~\origin{positive supercompilation}~\cite{scPos}.
К примеру, при достижении условного выражения
{\bf if} x $=$ a {\bf then} $t_1$ {\bf else} $t_2$
позитивный суперкомпилятор при вычислении $t_1$ будет учитывать то,
что x $=$ a, однако при вычислении $t_2$ он не будет знать, что
x $\neq$ a.
Расширение позитивного компилятора c поддержкой такой ``негативной''
информации --- идеальный
суперкомпилятор~\origin{perfect supercompilation}~\cite{scPerf}.

Техника суперкомпиляции в основном применяется для
функциональных~\cite{scHaskell, scPos} и императивных~\cite{scJava}
языков.
Для логических языков суперкомпиляция слабо развита, однако существует
посвящённые ей работы:
в работе~\cite{pdAndDriving} демонстрируется схожесть подходов частичной дедукции
и суперкомпиляции,
в работе~\cite{apropos} представлен позитивный суперкомпилятор APROPOS
для Prolog, однако эта версия довольно ограничена в своих возможностях
и требует ручного вмешательства.

%\todo{Кажется, нужны какие-то выводы}

% Общая схема суперкомпилятора представлена на рисунке~\ref{fig:scompScheme}
% \begin{figure}
% \center
% \includegraphics[scale=0.8]{./review/scompflow.pdf}
% \caption{Общая схема суперкомпилятора.}
% \label{fig:scompScheme}
% \end{figure}


% История вычислений при суперкомпиляции представляется в виде \emph{графа процессов} --- корневого ориентированного графа,
% в котором каждая ветвь --- это отдельный путь вычислений, а каждый узел --- состояние системы или \emph{конфигурация}.
% Конфигурация обобщённо описывает множество состояний вычислительной системы или её подсистемы.
% К примеру, конфигурацией можно назвать выражение $1 + x$, в котором параметр $x$ пробегает
% все возможные значения своего домена (допустим, множество натуральных чисел) и задаёт
% таким образом множество состояний программы\cite{turchinSC}.

% Процесс построение графа процессов называется \emph{прогонкой}~\origin{driving}.
% Во время прогонки производится шаг символьных вычислений, после которого
% в граф процессов добавляются порождённые конфигурации; множество конфигураций
% появляется тогда, когда ветвления в программе зависят от свободных переменных.

% В процессе прогонки в конфигурациях могут появляться новые свободные переменные,
% которые строятся из исходной конфигурации:
% если при вычислении выражения его переменная перешла в другую переменную (к примеру, из-за сопоставления с образцом),
% то в итоговую конфигурацию будет подставлена новая переменная и связь старой и новой сохранится в
% некоторой \emph{подстановке}.
% Подстановка --- это отображение из множества переменных в множество возможно замкнутых термов.
% Применение подстановки к выражению заменит все вхождения переменных, принадлежащих её домену,
% на соответствующие термы. %\todo{Что-нибудь ещё}

% Пример графа процессов представлен на рисунке~\ref{fig:pgraphExample}.
% \begin{figure}[h!]
% \center
% \begin{tikzpicture}[->,node distance=3cm, sibling distance=5cm]
                                                            
%   \tikzstyle{conf}=[rectangle,draw, rounded corners=.8ex]

%   \node[conf] (root) {$(a + b) + c$} ;
%   \node[conf] (childLeft) [below left of = root] {$b + c$};
%   \node[conf] (childRight)[below right of = root] {$(\text{Succ}(a_1) + b) + c$};
%   \path (root) edge node[above left,pos=1] {$\{a \mapsto \text{Zero}\}$} (childLeft)
%         (root) edge node[above right,pos=1]{$\{a \mapsto \text{Succ}(a_1)\}$}(childRight);
% \end{tikzpicture}

% \caption{Пример части графа процессов.}
% \label{fig:pgraphExample}
% \end{figure}
% Здесь при исполнении выражение $(a + b) + c$, где $a, b, c$ -- натуральные числа,
% были рассмотрены возможные значения $a$: это либо оно равно нулю (конструктор Zero), либо это некоторое
% число $a_1$, которому прибавили единицу (конструктор Succ). Эти два случая могут задают
% различные пути исполнения и, соответственно, добавлены в дерево процессов как два различных состояния,
% в одно из которых войдёт программа при исполнении.



% Потенциально процесс прогонки бесконечный, к примеру, когда происходят рекурсивные вызовы.
% Для превращения бесконечого дерева вычисления в конечный объект, по которому множно
% восстановить исходное дерево, используется \emph{свёртка.}

% Свёртка~\origin{folding}~--- это процесс преобразования дерева процессов в граф, при котором
% из вершины $v_c$ добавляется ребро в родительскую вершину $v_p$,
% если выражение в конфигурации в $v_c$ и в $v_p$ равны с точностью до переименования.
% Пример ситуации для свёртки изображён на рисунке~\ref{fig:pgraphFoldingExample},
% на котором свёрточное ребро изображено пунктиром.

% \begin{figure}[h!]
% \center
% \begin{tikzpicture}[->,node distance=2.3cm, sibling distance=5cm]
                                                            
%   \tikzstyle{conf}=[rectangle,draw, rounded corners=.8ex]

%   \node[conf] (root) {$a + b$} ;
%   \node[conf] (childLeft) [below left of = root] {$b$};
%   \node[conf] (childRight)[below right of = root] {$(\text{Succ}(a_1) + b)$};
%   \node[conf] (childRight2)[below  of = childRight] {$(a_1 + b)$};
%   \node (left)[below of = childLeft] {$\cdots$};

%   \path (root) edge node[above left,pos=1] {$\{a \mapsto \text{Zero}\}$} (childLeft)
%         (root) edge node[above right,pos=1]{$\{a \mapsto \text{Succ}(a_1)\}$}(childRight)
%         (childLeft) edge (left)
%         (childRight) edge (childRight2)
%         (childRight2) edge[bend right=90] (root);
% \end{tikzpicture}

% \caption{Пример свёртки. \todo{сделать соответствующим описанию в тексте.}}
% \label{fig:pgraphFoldingExample}
% \end{figure}

% Однако существует ситуации, при котором свёртка не приведёт к тому, что граф превратится в
% конечный объект. Такое может произойти, к примеру, когда два выражения структурно
% схожи, но не существует переименования, уравнивающих их: $a + b$ и $a + a$.

% Для решения этой проблемы используется \emph{обобщение}\cite{scGen}. Обобщение --- это процесс
% замены одной конфигурации на другую, более абстрактную, описывающую больше состояний
% программы. Для обнаружения ``похожей'' конфигурации используется предикат,
% традиционно называемый \emph{свистком}: свисток пробегает по всем
% родителям текущей конфигурации и определяет, похожа ли конфигурация на кого-то из них.
% В случае, когда свисток сигнализирует о найденной схожести, применяется обобщение.
% Сам шаг обобщения может произвести действия трёх видов:
% \begin{itemize}
% \item \emph{обобщение вниз} приводит к тому, что новая конфигурация заменяет текущую в графе процессов;
% \item \emph{обобщение вверх} приводит к замене родительской конфигурации на обобщённую;
% \item \emph{разделение}~\origin{split} используется для декомпозиции выражении, элементы которого затем
% будут обработаны отдельно.
% \end{itemize}
% Пример обобщения представлен на рисунке~\ref{fig:pgraphGenExample}

% \begin{figure}[h!]
% \includegraphics[scale=0.3]{./review/scgenex_temp.png}
% \caption{Пример обобщения \todo{свой рисунок}.}
% \label{fig:pgraphGenExample}
% \end{figure}

% Построение программы по графу конфигураций называется \emph{резидуализацией}, а
% построенная программа --- \emph{остаточной} \origin{residual}.
% Алгоритм выявления остаточной программы основан на обходе дерева, но
% в остальном полностью зависит от языка.

% \todo{Написать ещё про СК; продемонстрировать результаты СК; выводы}
