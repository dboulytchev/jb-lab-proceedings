{\bf Реляционное программирование}~--- это форма чистого логического
программирования, в которой программы задаются как набор
математических {\it отношений}~\cite{byrdMK}.
%Реляционное программирование ориентировано
%на получение \emph{значимых} ответов, как бы ни использовались отношения

Исторически, понятие реляционного программирования появилось
раньше~\cite{relML} и задавало саму концепцию программы как отношения,
когда логическое --- появилось позже и предоставляло реализацию его
идей~\cite{logicMJ}.
Однако в данной работе под реляционным программированием понимается
непосредственно то, что указано выше в определении.

В терминах реляционного программирования, к примеру, сложение $X + Y = Z$
может быть выражено отношением\footnote{Символ $\ ^o$ традиционно
используется для обозначения отношения.}
\[\text{add}^o (X, Y, Z),\]
которое в зависимости от того, какие переменные заданы, порождает
все возможные значения переменных, при которых отношение выполняется:
\begin{itemize}
\item \relo{add}(1, 2, 3) --- проверка, что значения находятся в отношении;
\item \relo{add}(1, 2, A) --- поиск всех таких A, при которых 1 + 2 = A;
\item \relo{add}(A, B, 3) --- поиск всех таких A и B, при которых A + B = 3;
\item \relo{add}(A, B, C) --- поиск всех троек A, B и С, при которых A + B = C.
\end{itemize}

Чистые отношения не предполагают функциональных зависимостей между переменными,
поэтому поиск можно проводить в разных ``направлениях'', в зависимости от
того, какие переменные заданы, как показано выше в примере.

%Когда же отношения вырождаются в функциональные и появляется
%явная зависимость между переменными, тогда можно говорить про запуск
Для функциональных отношений можно ввести понятие направления: для запуска
в ``прямом'' направлении задаются входные аргументы, а для запуска в
``обратном'' задаётся результат.

К примеру, отношение ``меньше'' для двух чисел X и Y можно задавать как
\relo{less}(X, Y) и получить чистое реляционное отношение.
Отношение же с функциональной зависимостью ---
\relo{$\text{less}_2$}(X, Y, R), где R сообщает, состоят ли X и Y
в отношении, и тогда задание X и Y будет
прямым направлением, а задание R --- обратным.

% Отличительная черта реляционного программирования в том, что с каким бы
% набором аргументов отношение ни было запущено, обязательно должны быть
% найдены все ответы, если они есть. Для сравнения, в Prolog

% Ссылка на Булычева
Одно из применений реляционной парадигмы --- {\it реляционные интерпретаторы}.
Для языка $L$ его интерпретатор -- это функция $\text{eval}_L$, которая принимает
на вход программу $p_L$ на этом языке, её вход $i$ и возвращает некоторый выход $o$:
\[ \text{eval}_L (p_L, i) \equiv \llbracket p_L \rrbracket (i) = o \]
Реляционную версию интерпретатора можно представить как отношение:
\[ \text{eval}_L^o(p_L, i, o). \]

При запуске такого отношения в разных направлениях можно не только вычислять результат,
но и по программе $p_L$ и выходу $o$
искать возможные входы $i$ или вовсе генерировать программу по указанным
выходам и входам.
% решать задачи поиска по задаче распознавания~\cite{lozov},
%генерировать программы по заданной спецификации входа $i$ и выхода $o$~\cite{unifiedMK}.

Можно отметить, что в языках, основанных на классическом Prolog, производить
подобные вычисления для получения осмысленных результатов значительно труднее.
%для достижения адекватной производительности используются операторы
%отсечения, при которых код теряет реляционную гибкость.
