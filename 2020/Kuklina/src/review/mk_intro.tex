% Byrd
{\it miniKanren} -- семейство встраиваемых предметно-ориентированных языков,
специально спроектированное для реляционного программирования~\cite{byrdMK}.

Основная реализация miniKanren написана на языке Scheme~\cite{reasonedSchemer},
однако существует множество реализаций в ряде других языков, в том числе
Clojure, OCaml, Haskell и другие\footnote{Официальный сайт языка miniKanren: \url{minikanren.org}, дата последнего посещения: 19.05.2020}.

miniKanren предоставляет набор базовых конструкций: унификация ($\equiv$),
конъюнкция $(\land)$, дизъюнкция $(\lor)$, введение свежей переменной
(\lstinline{fresh}), вызов реляционного отношения,
--- представляющий ядро языка, и разнообразные расширения, к примеру, оператор неэквивалентности
\origin{disequality constraint} или операторы, не являющиеся чистыми, к примеру, предоставляющие функциональность
отсечения из Prolog. Хотя в miniKanren введены операторы с эффектами,
его использование как реляционного языка подразумевает работу только с чистыми операторами.

Классический пример --- программа конкатенации двух списков --- указан
на рисунке~\ref{fig:appendo}.
Здесь список \lstinline{R} является конкатенацией списков \lstinline{X} и
\lstinline{Y} в случае, когда список \lstinline{X} пуст, а \lstinline{Y}
равен \lstinline{R}, либо когда \lstinline{X} и \lstinline{R} декомпозируются
на голову и хвост, а их хвосты состоят в отношении конкатенации с \lstinline{Y}.

\begin{figure}[h!]
\begin{lstlisting}[mathescape,language=Haskell,extendedchars=\true,frame=single,basicstyle=\ttfamily]
$\text{append}^o$ X Y R =
  X $\equiv$ [] $\land$ Y $\equiv$ R $\lor$
  fresh (H X' R')
    (X $\equiv$ H :: X') $\land$
    (R $\equiv$ H :: R') $\land$
    $\text{appendo}^o$ X' Y R'
\end{lstlisting}

\caption{Пример программы на miniKanren (\lstinline{::} --- конструктор списка)}
\label{fig:appendo}
\end{figure}

Для выполнения конкатенации над списками необходимо сформировать
\emph{запрос}~(или \emph{цель}).
В запросе в аргументах указываются либо замкнутые термы, либо термы
со свободными переменными. Результатом выполнения является список
подстановок для свободных переменных, при которых отношение выполняется;
когда свободных переменных нет, подстановка, соответственно, пустая.
Полное отсутствие каких-либо подстановок говорит об отрицательном результате
выполнения запроса.

На рисунке~\ref{fig:appendoExample} приведён пример запроса, в котором мы хотим
найти возможные значения переменных \lstinline{Y} и \lstinline{R}. Потенциально
может быть бесконечное число ответов, к примеру, когда все аргументы в запросе
--- переменные, поэтому в системах miniKanren есть возможность запрашивать
несколько первых ответов; в примере, это число 1. Ответы могут содержать в себе
как конкретные замкнутые термы (к примеру, числа), так и свободные переменные,
которые в примере обозначаются как $\text{\_.}_n$. В примере одна и также
свободная переменная $\text{\_.}_0$ назначена и \lstinline{Y}, и \lstinline{R}.
Это означает, что какое бы ни было значение \lstinline{Y}, оно всегда будет
являться хвостом хвоста \lstinline{R}.

\begin{figure}[h!]
\begin{lstlisting}[mathescape,language=Haskell,extendedchars=\true,frame=single,basicstyle=\ttfamily]
> run 1 (Y R) ($\text{append}^o$ [1, 2] Y R)
Y = $\text{\_.}_0$
R = 1 :: 2 :: $\text{\_.}_0$
\end{lstlisting}
\caption{Пример выполнения запроса к отношению конкатенации.}
\label{fig:appendoExample}
\end{figure}

В определение miniKanren входит особый алгоритм поиска ответов --- чередующийся
поиск \origin{interleaving search}, %основанный на поиске в глубину,
который рассматривает всё пространство поиска и является
полным~\cite{interleaving}.
% гарантирует, что если существует ответ, то алгоритм его предоставит за конечное время\cite{interleaving}.
%Для сравнения, обычный поиск в глубину, используемый в классическом Prolog при методе резолюций, может зациклиться
%или разойтись перед тем, как предоставить все ответы.
Это свойство чередующегося поиска определяет, вместе с отсутствием
нечистых расширений, реляционность miniKanren. 

% Применимость
Хотя miniKanren уже применяется в индустрии для поиска лечения редких
генетических заболеваний в точной медицине~\cite{medMK},
на данном этапе своего развития используется в основном в исследовательских
целях:
\begin{itemize}
\item реляционные интерпретаторы на miniKanren для решения задач поиска~\cite{lozov};
\item техника программирования по примерам~\cite{unifiedMK};
\item для доказательства теорем~\cite{mkProver} ;
\item в области вычислительной лингвистики~\cite{mkLing}.
\end{itemize}

%Одно из интересных применений miniKanren --- {\it реляционные интерпретаторы}.
%Для языка $L$ его интерпретатор -- это функция $\text{eval}_L$, которая принимает
%на вход программу $p_L$ на этом языке, её вход $i$ и возвращает некоторый выход $o$:
%\[ \text{eval}_L (p_L, i) \equiv \llbracket p_L \rrbracket (i) = o,\]
%где $\llbracket \bullet \rrbracket $ --- семантика языка L.
%Тогда в miniKanren интерпретатор описывается отношением $\text{eval}^o_L(p_L, i, o)$.
%При запуске такого отношения на разном наборе аргументов можно добиться интересных эффектов:
%\begin{itemize}
%\item по программе $p_L$ и выходу $o$ искать возможные входы $i$ (запуск программы в обратном направлении);
%  %: $\text{eval}^o(\text{add}, I, 3)$
%\item решать задачи поиска по задаче распознавания~\cite{lozov};
%\item генерировать программы по заданной спецификации входа $i$ и выхода $o$
%(техника программирования по примерам)\cite{unifiedMK}.
%\end{itemize}

% \todo{проблемы miniKanren: долгое вычисления сложных алгоритмов, долгие вычисления в обратном направлении.}
Однако miniKanren обладает рядом существенных недостатков. Несмотря на то,
что он ближе всего подошёл к реализации чистой реляционности, вычислительно
он всё же зависим от сложности и ветвистости программ, из-за чего их запуск в
разных направлениях может работать с разной скоростью, в особенности запуск в обратном направлении,
который зачастую работает очень медленно.
Также, описывать сложные задачи в качестве отношений --- нетривиальная задача,
наивно написанные реляционные программы вычисляются крайне неэффективно.
Из-за чего, к примеру, существует транслятор из функционального языка в
miniKanren~\cite{trconv}, однако порождаемые им отношения --- функциональные,
а запуск их в обратном направлении, как указывалось выше, крайне
непроизводителен~\cite{lozov}.

Одно из возможных решения проблем производительности --- специализация.
