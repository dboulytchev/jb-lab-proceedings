
% ------------------------------------------------------------------------------
%                             Введение
% ------------------------------------------------------------------------------
\section*{Введение}

Системы реального времени --- это программно-аппаратные системы, корректность работы которых
  зависит не только от результата вычисления, но и от времени, за которое вычисляется
  этот результат. Временные ограничения возникают из-за активного взаимодействия таких
  систем с окружающей средой. Системы реального времени применяются во многих областях:
  в управлении автомобильными двигателями, в авионике и судостроении, при управлении
  технологическими процессами, а также военными системами и космическими объектами.

При разработке систем реального времени часто создаются теоретические модели, с
  помощью которых возможно получить различные свойства
  таких систем --- наихудшее время ожидания задач системы, отсутствие тупиков и т.д.
  Эти свойства можно использовать при оценке качества системы.
  При этом остро стоит вопрос проверки корректности этих свойств.
  В последнее время появляется всё больше примеров, когда при последующем анализе
  теоретических моделей обнаруживаются ошибки. Например, в \cite{Bril06messageresponse}
  показано, что анализ модели времени отклика шины CAN \cite{Tindell1994AnEA}
  был частично неверным, ошибка была найдена только более чем через десять лет после
  первой публикации статьи и выпуска первой версии системы. В недавней работе \cite{nelissen}
  были описаны недостатки в анализе модели self-suspension \cite{lakshmanan:1},
  в обзоре \cite{chen} приведено большое количество  подобных проблем.

В области систем реального времени актуальной проблемой является планирование
  задач. При этом строятся различные модели такого планирования, которые в дальнейшем
  реализуются непосредственно в самих системах. Именно для этих моделей доказываются
  различные, важные с точки зрения практики, свойства.
  Рассмотрим две таких модели: модель статического планирования (Fixed Priority, FP)
  и модель планирования по ближайшему сроку завершения --- самая популярная разновидность
  динамического планирования (Earliest Deadline First, EDF). Статическое планирование
  означает, что приоритеты исполнения задач системы присваиваются на этапе
  проектирования и являются фиксированными. Для сложных систем такой подход оказывается
  неэффективным \cite{Liu1973SchedulingAF}, целесообразным оказывается использовать
  динамических моделей, когда решение о присвоении приоритета выполнения задачи
  принимается во время работы системы \cite{Baruah2003DynamicAS, Becker2001ExecutionEF, Spuri1996SchedulingAT}.
  Существует обширная литература по исследованию и применению этих моделей
  \cite{Campoy2004SchedulabilityAI, Kwok1999StaticSA, Sakellariou2007SchedulingWW, Wang1999SchedulingFT}.

В данной работе мы сфокусируемся на одной известной проблеме из области планирования
  систем реального времени, связанной с планированием множества задач. Данная
  проблема формулируется так: пусть имеются политика вычисления, политика присвоения
  приоритетов и множество задач с ограничениями; требуется определить, является ли
  это множество задач планируемым. Другими словами, требуется ответить
  на вопрос о том, правда ли, что любая задача удовлетворяет своим временным ограничениям.

Для решения этой проблемы в \cite{Lehoczky1990FixedPS} был предложен метод интервала
  занятости (busy interval method). Суть метода заключается в рассмотрении специально
  сконструированного интервала, в котором рассматриваемая задача системы  испытывает максимальное количество
  помех со стороны других задач. Утверждается, что внутри такого интервала достигается
  наихудшее время ожидания для рассматриваемой задачи, которое можно вычислить по этому интервалу.
  Этот метод имеет основополагающее
  значение для анализа наихудшего времени ожидания задач, на его основе построено
  множество теоретических оценок \cite{Bertogna2005ImprovedSA, Guo2015EDFSA, Lehoczky1990FixedPS,
  Zhang2009SchedulabilityAF}. Однако формулировка метода варьируется от статьи к
  статье, при этом не всегда доказывается корректность модификаций
  метода, не во всех статьях применимость метода проверяется явно. Неаккуратное
  обращение с методом интервала занятости привело к ошибке, описанной в
  \cite{Bril06messageresponse}. Таким образом, необходим более строгий подход к
  получению теоретических результатов, основанных на методе интервала занятости.

 Следует отметить, что доказательства в этой области оказываются очень
  объемными и в то же время относительно простыми. С другой стороны, выдвигаются повышенные требования
  к качеству таких доказательств --- как указывалось выше, постоянно находятся ошибки
  в доказательствах различных свойств  для моделей систем реального времени.
  Таким образом, необходим строгий и надёжный подход к получению теоретических результатов, основанный
  на формальных, полностью проверенных доказательствах. Для того, чтобы минимизировать
  возможность ошибок в этих доказательствах, они могут быть механизированы,
  т.е. должны быть выполнены и автоматически
  проверены с помощью интерактивного программного средства доказательства теорем,
  такого как Coq \cite{Coq}. Подобные средства обладают достаточной аналитической
  мощностью, доступны в течение многих лет и уже были успешно использованы для формальной
  проверки сложного программного обеспечения, например, при разработке компиляторов
  \cite{leroy}, ядер ОС \cite{klein}, файловых систем \cite{chen:2}. Так же с их
  помощью были механизированы нетривиальные математические доказательства некоторых
  теорем, таких как Four Color Theorem \cite{gonthier:1} и Odd Order Theorem \cite{gonthier:2}.
  Тем не менее, данные средства пока не получили широкого распространения в сообществе
  систем реального времени.

Проект Prosa \cite{Prosa} института Макса Планка (Кайзерслаутерн, Германия) нацелен
  на создание формализованных основ теории планирования систем реального
  времени и, в числе прочего, на применение системы Coq.
  Получение формализованного доказательства на языке Coq требует существенно больше
  усилий, чем неформальное доказательство на бумаге.

Таким образом, целью данной работы является исследование границ применимости метода интервала занятости
  и создание механизированного доказательства с помощью интерактивного
  программного средства доказательства теорем Coq. Для достижения этой цели были поставлены
  следующие задачи.

\begin{itemize}
    \item Выполнить доказательство теоремы о корректности метода интервала занятости
      в общем виде и сформулировать минимальный набор предположений о планировщике
      для системы с одним процессором.
    \item На основании теоремы о корректности метода интервала занятости доказать
      теорему о корректности оценки наихудшего времени ожидания задачи для практически
      важной модели FP-планирования.
    \item На основании теоремы о корректности метода интервала занятости доказать
      теорему о корректности оценки наихудшего времени ожидания задачи для практически
      важной модели EDF-планированиян.
\end{itemize}

% ------------------------------------------------------------------------------
%                             Обзор
% ------------------------------------------------------------------------------
\section{Обзор}
В данной главе введены основные термины и определения, используемые в работе, а также
  рассмотрены основные подходы к анализу времени ожидания в системах с одним процессором.
  Также рассмотрены модели планирования FP и EDF, использованные в данной работе.
  Кроме того, описаны технологии, использовавшиеся при разработке доказательств
  теорем о корректности метода интервала занятости и корректности оценок наихудшего
  времени ожидания задачи.

\subsection{Основные понятия}

Для описания различных типов систем реального времени и методов планирования и управления
  ресурсами нам удобнее говорить о работах, выполняемых вычислительными
  или коммуникационными системами, в абстрактных терминах. Так, любой вид работы,
  выполняемый системой (вычисление команды процессором или передачу сообщения),
  будем называть \textbf{работой}. \textbf{Задачей} является набор связанных работ, которые совместно
  реализуют некоторую системную функцию. Вместо того, чтобы использовать разные
  глаголы (например, вычислять или передавать) для разных типов работ, мы всегда
  будем говорить, что работа выполняется системой.

В данном исследовании используется дискретный способ представления времени.
  Есть несколько причин для такого выбора. Во-первых, дискретное
  время позволяет использование той же индукционной гипотезы, что и для натуральных чисел.
  Например, если нам необходимо
  доказать, что любая работа удовлетворяет некоторым временным ограничениям, мы можем
  воспользоваться сильной индукцией (strong induction) по времени, чтобы получить теорему вида: "пусть все работы,
  которые появились до времени $t$, удовлетворяют временным ограничениям;
  докажем, что работа, которая появилась в момент времени $t + 1$, удовлетворяет
  своим временным ограничениям". Во-вторых, такое определение времени соответствует
  реализации, где время дискретно с точностью до одного цикла процессора.

Каждой работе $J$ соответствует момент времени $t$, когда эта работа становится
  доступной для исполнения; для краткости мы будем говорить, что работа $J$
  \textbf{появилась} в момент времени $t$. Предполагается, для любой работы известна задача,
  которая её \textbf{произвела}.

Хотя планировщик может быть описан в виде некоторого алгоритма, мы абстрагируемся от
  деталей реализации и будем использовать более формальное описание. \textbf{Планировщик}
  --- это функция, действующая из времени в множество работ. В терминах языка Coq
  планировщик без реализации можно описать следующей строкой: $Variable \ sched: time
  \rightarrow option (Job)$. Ситуация, когда в какой-то момент времени не запланировано
  ни одной работы, называется \textbf{простоем системы}. Мы будем говорить, что планировщик
  \textbf{сохраняет работу}, если в любой момент, когда в системе есть
  ожидающая работа, запрещена ситуация простоя.

Далее, мы будем говорить, что в момент времени $t$ работа $J$ \textbf{выполняется} системой,
  если планировщик запланировал работу в этот момент времени (то есть, $sched(t) = Some(J)$).
  Суммарное количество времени $t' \in [0, t)$, когда работа $J$ выполнялась,
  называется \textbf{сервисом} работы $J$ в момент времени $t$.
  \textbf{Стоимость работы} --- это количество сервиса, которое должна получить работа,
  чтобы считаться завершённой. Работа $J$ в момент времени $t$ считается \textbf{ожидающей},
  если $J$ появилась в момент времени $t' \leq t$ и в момент времени $t$ не является завершённой.
  Количество времени, которое работа $J$ является ожидающей, называется \textbf{временем ожидания работы} $J$ ($r_J$).


\textbf{Дедлайн} --- это момент времени, к которому работа должна быть завершена. Мы
  будем пользоваться двумя типами дедлайнов: относительным и абсолютным. Относительный
  дедлайн $D_i$ определяется для задачи и задаёт допустимый
  диапазон времени для завершения любой работы произведённой задачей. Абсолютный дедлайн определяется
  для работы, обычно он равен сумме времени появления работы и относительного дедлайна задачи.
  Работа пропускает дедлайн, если она завершится позже абсолютного дедлайна.

Системы реального времени классифицируются по гибкости дедлайнов. Важным частным случаем
  является неявный (implicit) дедлайн: набор (спорадических) задач
  $\tau$ имеет неявный дедлайн, если $D_i = P_i$ для каждой $T_i \in \tau$. Более
  общим случаем являются ограниченный (constrained) дедлайн, где $D_i \leq P_i$
  для каждой задачи $T_i \in \tau$. В противном случае, если набор задач не имеет неявных
  или ограниченных дедлайнов, то говорят про произвольные (arbitrary) дедлайны.

В данной работе рассматриваются только системы с жесткими дедлайнов. Для планируемости
  системы необходимо, чтобы все работы выполнялись до их абсолютных дедлайнов, что
  эквивалентно требованию, что наихудшее время ожидания любой задачи ограничено ее
  относительным дедлайном, т.е. $R_i \leq D_i$. Очевидно, что время ожидания зависит
  от модели планирования и конкретных сроков появления работы и
  загруженности процессора высокоприоритетными заданиями, которые не позволяют
  выполнить рассматриваемую работу.

Политика планирования присваивает каждой работе \textbf{приоритет}. Обозначим через
  $\pi (J, t) $ приоритет работы $J$ в момент времени $t$. Имея функцию определения
  приоритетов $\pi(\cdotp, \cdotp)$, мы можем выделить три основных класса планировщиков.
  В планировщиках с фиксированными приоритетоми все работы, произведённые одной задачей,
  имеют один общий (постоянный) приоритет, то есть фиксированные приоритеты присваиваются
  задачам, а приоритеты работ равны приоритетам задач, которая их произвели.
  Формально, $\pi(J_{i, x}, t_1) = \pi (J_{i, y}, t_2)$ для любых двух работ $J_{i, x}$
  и $J_{i, y}$ из одной задачи и любых двух моментов времени $t_1$ и $t_2$. Вариация
  приоритетов для разных работ одной задачи допускается в планировщиках с фиксированным
  приоритетом на уровне работ (job-level fixed-priority, JLFP), приоритет должен
  быть зафиксирован в момент появления работы.  Формально, $\pi (J_{i, x}, t_1) = \pi (J_{i, x}, t_2)$
  для любых двух моментов времени $t_1, t_2$. Класс планировщиков JLFP включает
  планировщики FP. Наиболее общим классом планировщиков являются планировщики с
  динамическими приоритетами (job-level dynamic-priority, JLDP). В JLDP-планировщике
  приоритет работы может измениться в любое время.

С другой стороны, политика планирования определяет то, что произойдёт, если
  во время выполнения некоторой работы $J$ появится работа $J_{hp}$ с более высоким
  приоритетом. Стоит упомянуть некоторые наиболее популярные политики. В \cite{Liu1973SchedulingAF}
  представлена полностью вытесняемая модель планирования, в которой планировщик
  может вытеснить любую работу в любой момент времени. В \cite{Jeffay1991OnNS} описана
  полностью невытесняемая модель, в которой если планировщик начал выполнение работы,
  то она не может быть отложена даже если имеется работа с более высоким
  приоритетом, ожидающая своего исполнения. Существуют и смешанные модели, когда
  работа может быть вытеснена только в определённые моменты времени. Также существует
  модель плавающих невытесняемых сегментов, когда мы точно не знаем разбиение работы на
  невытесняемые сегменты \cite{Bertogna2011ImprovingFO}. Во всех этих случаях для вычисления оценки
  наихудшего времени ожидания задачи необходимо иметь только длину максимального и последнего
  невытесняемых сегментов работы.

Мы говорим, что работа $J_{hp}$ с более высоким приоритетом создаёт помехи для выполнения работы $J$,
  если работа $J_{hp}$ выполняется, пока работа $J$ ждёт своего выполнения.
  Иначе мы говорим, что работа $J$ блокирует выполнение работы $J_{hp}$.

Дадим теперь формальное определение понятия работы.

\textsc{Определение 1.}
\textit{Работа $J_{i, j}$ --- это шестерка $\langle a_{i, j}, c_{i, j}, d_{i, j}, q_{i,j}^{last}, q_{i,j}^{max}, task \rangle$, где:
    \begin{itemize}
        \item $a_{i, j}$ --- момент времени, в который работа $J_{i, j}$ появляется;
        \item $c_{i, j}$ --- стоимость работы;
        \item $d_{i, j}$ --- абсолютный дедлайн работы;
        \item $q_{i,j}^{last}$ --- длина последнего невытесняемого сегмента работы $J_{i, j}$;
        \item $q_{i,j}^{max}$ --- максимальная длина невытесняемого сегмента работы $J_{i, j}$;
        \item $task$ --- задача, которая произвела работу $J_{i, j}$.
    \end{itemize}
}


Рассчитать оценку наихудшего времени ожидания для такой системы всё ещё не представляется возможным. Нам необходимо ввести ограничения на стоимость работ, на минимальную и максимальную
  длину дедлайна, а также на частоту появления работ. Для этого вводится понятие
  задачи. Задача выступает в роли абстрактной сущности, которая позволяет ввести ограничения на работы, которыми будет манипулировать планировщик.

Мы предполагаем, что нам известно анализируемое множество задач $\{T_1, ... , T_n\}$, и каждая работа принадлежит одной из этих задач. Введём нижние индексы для обозначения принадлежности работ к задачам. $J_{i,j}$ обозначает $j$-ую по счету работу, которую произвела задача $T_i$. Таким же образом поступим со всеми характеристиками работы, то есть $a_{i, j}$ означает момент появления работы $J_{i,j}$. Каждой задаче соответствует \textbf{кривая прибытия} ($AC_i(R)$) --- это функция, которая определяет максимальное количество появлений различных работ задачи $T_i$ в любом промежутке длины $R$. Более формально: $\forall t\ R: \#\{J_{i, \cdot} | a_{i, \cdot} \in [t, t + R)\} \leq AC_i(R)$.

Рассмотрим так называемые спорадические задачи. В этом случае существует константа $P_i$, называемая периодом, для спорадических задач кривая прибытия определяется как $AC_i(t) = \left \lceil \dfrac{t}{P_i} \right \rceil$. Интуитивно это значит, что работы одной задачи не могут появляться слишком часто.

Введём понятие задачи формально.

\textsc{Определение 2.}
\textit{Задача $T_i$ --- это пятерка $\langle C_i, AC_i, D_i, q_{i}^{last}, q_{i}^{max}, \rangle$, где:
    \begin{itemize}
        \item $C_i$ --- это максимум стоимости для работы, произведённой данной задачей;
        \item $AC_i$ --- кривая прибытия задачи;
        \item $D_i$ --- относительный дедлайн задачи;
        \item $q_{i}^{last}$ --- верхняя граница длины последнего невытесняемого сегмента работы, произведённой задачей;
        \item $q_{i}^{max}$ --- верхняя граница длины невытесняемого сегмента работы, произведённой задачей.
    \end{itemize}
}

\textbf{Наихудшее время ожидания} задачи $T_i$ определяется как $R_i = \max_{j} {(r_{i, j})}$. Поскольку задачи производят потенциально бесконечное количество работ, то $R_i$ может быть не определено для некоторых задач. Например, если система перегружена, то $r_{i, j}$ может монотонно возрастать с каждой новой работой $J_{i, j}$.

\subsection{Метод интервала занятости}

Нахождение наихудшего времени ожидания задачи является нетривиальной проблемой. Вопреки нашей
  интуиции, наихудшее время ожидания задачи не всегда достигается при простом запуске
  всех задач на максимально возможной мощности. Поэтому используется метод интервала занятости, который впервые был
  введён в работе \cite{Lehoczky1990FixedPS}. Метод интервала занятости предлагает
  рассмотрение специально сконструированных интервалов (интервалов занятости), в
  которых работы рассматриваемой задачи испытывают максимальное количество помех.
  Утверждается, что для одной из работ, которая выполнялась внутри интервала занятости,
  достигается наихудшее время ожидания задачи.

Однако не существует сложившегося определения интервала занятости и того, как должен
  строиться его дальнейший анализ. Далее будут описаны некоторые определения
  интервала занятости, а затем и сам метод интервала занятости.

Наиболее ранней попыткой получения оценки наихудшего времени ожидания задачи
  является подход, в котором наихудший сценарий исполнения строился явно.
  Подразумевается, что необходимо запустить одновременно все задачи на максимально возможной мощности,
  то есть, каждая задача должна максимально часто производить работы с максимально
  возможной стоимостью. Оказалось, что такой способ построения наихудшего случая
  даёт правильную оценку только в самых простых ситуациях. Например, в случае задач
  с произвольными дедлайнами, наихудший случай при таком сценарии не достигается.
  Способ, описанный выше, сильно повлиял на определение интервала занятости
  и сам метод.

В \cite{Lehoczky1990FixedPS} вводится понятие интервала занятости i-уровня.

\textsc{Определение 3.}
\textit{Интервал занятости $i$-уровня --- это интервал времени $[a,b]$, в котором каждая
  работа с приоритетом $i$ или выше выполняется внутри $[a,b]$, но нет ни одной работы
  с приоритетом $i$ или выше, выполняющихся в $(a - \epsilon, a)$ или $(b, b + \epsilon)$
  для достаточно малого $\epsilon > 0$.
}

Стоит обратить внимание на некоторые существенные недостатки этого определения.
  Первоначально определение было введено для FP-планировщиков, поэтому
  в нём фигурирует понятие "приоритета i и выше", поскольку в случае JLFP-планировщиков каждая
  работа может иметь свой уникальный приоритет, из-за чего приоритетов становится
  слишком много, что вызывает сложности при работе с этим определением. Также, такое
  определение не позволяет рассматривать некоторые корректные расписания. И оно совершенно
  не подходит для любой модели планирования, где работы имеют невытесняемые сегменты.

Ниже приведено наиболее формальный вариант определения интервала занятости.

\textsc{Определение 4.}
\textit{Интервал $[t_1, t_2)$ называется i-интервалом занятости, если:
    \begin{itemize}
        \item $t_1$ --- момент времени, в который все работы с приоритетом i и выше, которые появились до $t_1$, закончены, и существует работа с приоритетом i или выше, которая появилась в момент времени $t_1$;
        \item $t_2$ --- момент времени, в который все работы с приоритетом i или выше, которые появились после момента времени $t_1$, завершены.
    \end{itemize}
}

Определение 4 исправляет многие недостатки определения 3. Но в этом определении всё
  ещё используется понятие i-приоритетов. Но определение 4 возможно использовать в
  моделях планирования с невытесняемыми сегментами.
  Также учтены проблемы определения 3 с некоторыми корректными случаями.

Определением 4 поиски хорошего определения интервала занятости не заканчиваются.
  И \cite{Grolleau2007TutorialOR}
  описано понятие загрузки процессора (processor demand concept) для случая EDF-планирования.
  А в работе \cite{Harbour2003ResponseTA} интервал занятости определяется как интервал,
  в котором система выполняет любую работу и который заканчивается
  в момент начала простоя системы. В более поздней работе \cite{Wang1999SchedulingFT} всё ещё
  используется понятие критического момента. В работе \cite{Bertogna2011ImprovingFO}
  вводится определение, которое по смыслу идентично определению 4, но называется по-другому
  и вводится в неформальном ключе.

Такие сильные разночтения в одном из фундаментальных определений метода
  приводят к ещё большим разногласиям в том, что такое метод интервала занятости и
  как его следует использовать.

В итоге оказывается сложным явно описать метод интервала занятости. Сформулируем его некоторые характерные основные шаги.
\begin{enumerate}
    \item Из множества задач выбирается анализируемая задача $T_i$.
    \item Для этой задачи вычисляется максимальная длина интервала занятости, что необходимо для того, чтобы ограничить пространство поиска из пункта 3.
    \item Далее определяется пространство поиска параметров $SP$, для которых будет производиться поиск наихудшего сценария выполнения работы из задачи $T_i$. В большинстве случаев это просто номер работы из задачи $T_i$, которая оказалась в рассматриваемом интервале занятости.
    \item Для каждого случая из $SP$ составляется расписание и вычисляется время ожидания $r_{i}$ соответствующей работы.
    \item Находится максимум среди полученных времени ожиданий для работ ($max_{i\in SP} (r_{i})$).
\end{enumerate}

Многое из вышеописанного может показаться просто неформальным обращением с определениями.
  В такой ситуации практически невозможно создать теорию, которая охватывала бы
  различные случаи одновременно. Такое разнообразие бессмысленно пытаться верифицировать.

\subsection{FP-планирование}

В случае FP-планирования, каждой задаче статически присваивается приоритет, который не меняется во время работы системы. Возникает два тесно связанных вопроса: (a) будет ли система планируема при данном распределении приоритетов, (b) как присвоить приоритеты задачам так, чтобы система была планируема. В \cite{Liu1973SchedulingAF} введено понятие rate-monotonic (RM) определения приоритетов. При присвоении приоритетов с помощью RM-политики, задачи с наименьшим периодом получают наивысший приоритет.


В контексте периодических задач с неявными дедлайнами в \cite{Liu1973SchedulingAF} показано, что RM-политика является оптимальной по отношению к FP-планировщикам (то есть, любой набор задач, для которого существуют такие приоритеты, что система планируема FP-планировщиком, так же планирум в случае, если приоритеты присвоить с руководствуясь RM-политикой). Была получена следующая теорема (адаптированная к спорадическим задачам).

\textsc{Теорема 1. }
\textit{(Liu and Layland, 1973). Пусть $\tau = \{T_1, ... , T_n\}$ --- множество спорадических задач с неявным дедлайном. Тогда если $\sum_{T_i \in \tau} \dfrac{C_i}{P_i} \leq n(2^{1/n} - 1)$, то $\tau$ планируемо при RM распределении приоритетов.
}

Оценка $n(2^{1/n} - 1)$ при $n \rightarrow \infty$ стремится к $\ln 2$, что примерно равно 0.69. В \cite{Liu1973SchedulingAF} показано, что это наивысший достижимый коэффициент загрузки для RM и, следовательно, существуют наборы задач с общей загрузкой, чуть превышающей эту границу, которые не могут быть распланированы никаким способом FP-планировщиком.

RM-политика не является оптимальной для не неявных дедлайнов. В \cite{LEUNG1982237} показано, что deadline-monotonic (DM) политика присвоения приоритетов, в которой задачам с кратчайшим относительным дедлайном присваивается наивысший приоритет, является оптимальной для наборов задач с ограниченными дедлайнами. Поскольку случай ограниченных дедлайнов обобщает случай неявных дедлайнов, DM-планирование обобщает RM-планирование. Можно получить аналог теоремы 1 для DM-планирования, заменив $\sum_{} \dfrac{C_i}{P_i}$ на $\sum_{} \dfrac{C_i}{D_i}$.

Точный тест планируемости для задач с ограниченными дедлайнами при FP-планировании (при произвольным присвоением приоритетов) был представлен в \cite{Joseph1986FindingRT}. Подход заключается в вычислении верхней границы $R_i$ на наихудшее время ожидания $r_i$ для каждой задачи в явном виде. Учитывая такую оценку для каждой задачи $T_i$, планируемость может быть установлена путем проверки того, что $\forall i \ j, r_{i,j} \leq R_i \leq D_i$. Константу $R_i$ можно найти, используя следующую теорему.

\textsc{Теорема 2.}
\textit{(Joseph and Pandya, 1986). Пусть $\tau = \{T_1, ... , T_n\}$ --- набор спорадических задач с ограниченными дедлайнами. При FP\-/планировании $r_{i,j}$ ограничены константой $R_i \geq C_i$, которая удовлетворяет следующему уравнению: $$ R_i = C_i + \sum_{T_j \in hp(T_i)} C_j \left \lceil \dfrac{R_i}{P_j} \right \rceil.$$
}

Вычислить $R_i$ можно итеративно, используя $C_i$ как начальное значение для $R_i$, при $\sum_{} \dfrac{C_i}{P_i} \leq 1$ сходимость итераций гарантируется \cite{Joseph1986FindingRT}. Использование теоремы 2 для определения планируемости, называется анализом времени ожидания задачи. В \cite{Baruah2006SustainableSA} показано, что анализ времени ответа является устойчивым (sustainable) и, следовательно, хорошо подходит для определения планируемости в практических системах. Аналогичные тесты, которые также оценивают наихудшее время ожидания, но могут сходиться быстрее, были позже разработаны в \cite{Audsley1991HardRS, Lehoczky1989TheRM}.

Одной из наиболее поздних работ в этом направлении является \cite{Bertogna2011ImprovingFO}, которая обобщает результаты описанные выше. В \cite{Bertogna2011ImprovingFO} рассмотрен случай FP-планирования с плавающими невытесняемыми сегментами. Введём некоторые обозначения, которые используются в этой теореме. Рассматривается набор спорадических задач с произвольными дедлайнами и плавающими невытесняемыми сегментами, упорядоченный по уменьшению приоритетов $\tau = \{T_1, ... , T_n\}$, а так же задача $T_i \in \tau$. Далее вводится выражение ограничивающее суммарные помехи от работ с более высоким приоритетом: $W_i(t) := \sum_{j = 1}^{i-1} C_j \left \lceil \dfrac{t}{P_j} \right \rceil$. Так как рассматривается модель с плавающими невытесняемыми сегментами, работы с более низким приоритетом также могут вызывать блокировку выполнения работы задачи $T_i$: $B_i := \max_{j>i} q_{j}^{max}$. Далее вводится оценка максимальной длины интервала занятости, её можно получить решив следующее уравнение: $L_i = B_i + \sum_{j = 1}^{i} C_j \left \lceil \dfrac{L_i}{P_j} \right \rceil$. Так как задачи спорадические, максимальное число работ задачи $T_i$ в одном интервале занятости ограничено константой $K_i := \left \lceil \dfrac{L_i}{T_i} \right \rceil$. Сформулируем теорему, на которой будет основываться дальнейшие рассуждения о FP-планировании.

\textsc{Теорема 3.}
\textit{Пусть $\tau = \{T_1, ... , T_n\}$ --- набор спорадических задач с
  произвольными дедлайнами и плавающими невытесняемыми сегментами. Тогда оценка
  наихудшего времени ожидания задачи $T_i$ равна: $$R_i = \max_{k \in [1..K_i]} \{ s_{i,k} + q^{last}_i - (k - 1) P_i\},$$
  где $s_{i,k} = B_i + kC_i - q^{last}_i + W_i(s_{i,k})$.
}

\subsection{EDF-планирование}

В противоположность FP-планированию, в случае EDF\-/планирования никаких заранее заданных приоритетов не требуется и работы исполняются в порядке увеличения времени абсолютных дедлайнов. Алгорим EDF-планирования является одиним из важнейших представителей JLFP-планировщиков. Абсолютные дедлайны не обязательно уникальны, так что у нескольких различных работ могут быть одинаковые приоритеты. Формально: приоритет работы $J_{i,j}$ определяется как $\pi (J_{i, j}, t) := D_{i, j}$, со следующей интерпретацией $\pi (J_{i, j}, t) \leq \pi (J_{x, y}, t) \Leftrightarrow D_{i , j} \leq D_{x, y}$. Можно заметить, что приоритет не зависит от времени.

EDF является значимой политикой планирования, так как является оптимальной для однопроцессорных систем \cite{Dhall, Liu1973SchedulingAF}, то есть в однопроцессорной системе, любой планируемй набор задач с произвольными дедлайнами является планируемым под EDF.

По этой причине, далее мы не рассматриваем другие типы JLFP- и JLDP- планировщиков. Хотя такие планировщики и существуют \cite{Davis1993SchedulingST}, они предлагают лишь незначительные преимущества по сравнению EDF и, таким образом, имеют ограниченную практическую значимость. Однако JLDP-политики имеют большое значение в контексте многопроцессорного планирования.

В случае спорадических задач с неявным дедлайном задачу планируемости множества задача можно свести к простому вычислению загруженности процессора.


\textsc{Теорема 4. }
\textit{(Liu, 1969a; Liu and Layland, 1973). В однопроцессорной системе набор спорадических задач с неявными дедлайнами планируем при EDF-планировании, тогда и только тогда, когда $\sum_{} \dfrac{C_i}{P_i} \leq 1$.
}


EDF является оптимальным и в случае произвольных дедлайнов. Тем не менее, тестирование на планируемость становится более сложным. Существует аналог теоремы 3 для EDF-планирования \cite{Harbour2003ResponseTA}. Введём обозначения, которые используются в этой теореме. Рассматривается набор спорадических задач с произвольными дедлайнами $\tau = \{T_1, ... , T_n\}$ и задача $T_a \in \tau$. Далее вводится функция ограничивающая максимальное количество помех от работ с более высоким приоритетом $$W_i(t, A) := C_i \min{ \left \{ \left \lceil \dfrac{t}{P_j} \right \rceil, \left \lfloor \dfrac{A - d_i}{P_j} \right \rfloor + 1 \right \} }.$$ Работы с более низким приоритетом также могут вызывать блокировку выполнения работы рассматриваемой задачи $B_i := \max_{j>i} C_{j}$. Cуммарная функция помех определяется следующим образом: $w_a^A(k) := B_a + k C_a + \sum_{j \neq a} W_j(w^A_a(k), D^A(k))$, где $D^A(k) := A + (k - 1)P_a + B_a $. Оценку на максимальную длину интервала занятости можно вычислить из следующего уравнения $L = \sum_{\forall j} C_j \left \lceil \dfrac{L}{P_j} \right \rceil$. Так как задачи спорадические, максимальное число работ задачи $T_a$ в одном интервале занятости ограничено константой $K_a := \left \lceil \dfrac{L}{P_a} \right \rceil$. Для краткости, здесь не приводятся ограничения на параметр $A$.

\textsc{Теорема 5. }
\textit{Пусть $\tau = \{T_1, ... , T_n\}$ --- набор спорадических задач с произвольными дедлайнами и плавающими невытесняемыми сегментами. Тогда оценка
  наихудшего времени ожидания задачи $T_a$: $$R_a = \max_{k \in [1, K_i], A \in ...} \{ w_a^A(k) - A  + (k - 1)P_a \}.$$}

Подведём итоги. Планирование задач в однопроцессорных системах на данный момент хорошо изучено. FP и EDF являются двумя наиболее релевантными политиками планирования. В однопроцессорной системе любой набор задач с неявными дедлайнами планируем EDF-планировщиком, если процессор не перегружен. В случае FP-планирования, мы подвержены потере производительности: до 30 процентов процессорной мощности, возможно, останется неиспользованной.

Тем не менее, FP-планирование гораздо более распространено на практике. Одной из причин является относительная простота внедрения этого алгоритма. И хотя также возможно использовать EDF \cite{Short2010ImprovedTM}, требуемые методы концептуально сложнее и не являются частью привычных инструментов разработчиков ОС (в отличие от FP). В \cite{Buttazzo2003RateMV} так же утверждается, что предпочтение FP еще больше подкрепляется распространенными заблуждениями и мифами относительно предполагаемых преимуществ на практике.

\subsection{Язык Coq и проект Prosa}

% Coq is an interactive theorem prover. It allows the expression of mathematical assertions, mechanically checks proofs of these assertions, helps to find formal proofs, and extracts a certified program from the constructive proof of its formal specification. Coq works within the theory of the calculus of inductive constructions, a derivative of the calculus of constructions. Coq is not an automated theorem prover but includes automatic theorem proving tactics and various decision procedures.

Coq --- интерактивное средство доказательства теорем. Он позволяет записывать
  формальные спецификации программ и математических утверждений, после этого Coq механически
  проверяет доказательства этих утверждений, а также, при необходимости, генерирует сертифицированные
  программы из доказательств формальных спецификаций. Coq не является автоматическим
  теоретическим доказательством, но включает в себя автоматические
  тактики поиска доказательств и различные процедуры принятия решений.

Термами в Coq могут быть программы, свойства этих программ
  а также доказательства этих свойств. Так как Coq в своём ядре использует
  идею изоморфизма Карри-Говарда, программы, свойства и доказательства формализуются на
  одном и том же языке, что и исчисление индуктивных конструкций. Все логические суждения
  в Coq являются суждениями о типе
  соответствующего терма. Таким образом, базовой частью системы Coq является алгоритм
  проверки типов, которая проверяет соответствует ли программа его спецификации
  или корректность доказательств.

Конечная корректность механизированного доказательства зависит только от корректности
  реализации средства доказательства теорем, в котором было выполнено это доказательство.
  Однако на исследователе остаётся задача составления
  формальной спецификации, которая в конечном итоге была бы понята и принята сообществом.
  Формальные определения и утверждения теорем должны быть такими же понятными,
  как и их неформальные аналоги. Таким образом, одной из важных целей остаётся сохранение
  спецификаций доступных для исследователей, знакомых с целевой областью исследования, но не
  имеющих опыта в формальных методах.

Для систем реального времени эта проблема также актуальна. Prosa является проектом,
  решающим эту проблему. Prosa --- исследовательский проект группы
  систем реального времени в институте Макса Планка (Кайзерслаутерн, Германия),
  направленный на создание надёжных оснований теории систем реального времени.
  Цель Prosa заключается не только в том, чтобы просто доказать правильность какого-либо
  конкретного анализа модели планирования, но и для создания переиспользуемых оснований
  анализа планирования, которые являются достоверно правильными, расширяемыми и
  все еще легко понятными человеку, знакомому с основами теории систем реального времени.

Таким образом, Prosa уделяет первоочередное внимание читабельности,
  чтобы гарантировать, что доказательства(specifications) остаются доступными для
  читателей не знакомых с основами формальных доказательств. Чтобы обеспечить полную
  корректность, доказательства в Prosa выполнены с помощью языка Coq \cite{Coq}.

На данный момент в проекте Prosa уже реализованы множество доказательств из области систем реального времени, таких как
  доказательство корректности оценки наихудшего времени ожидания для спорадической модели
  с джиттером (Release Jitter), для спорадической модели с параллельными работами,
  для спорадической модели с Arbitrary Processor Affinities (APA) и множества других.
  Также разработаны основы теории планирования self-suspension задач, которые сейчас являются
  одной из наиболее актуальных областей систем реального времени.
%   Данная работа была выполнена в рамках проекта Prosa \cite{Prosa}.

% ------------------------------------------------------------------------------
%                             Основные определения
% ------------------------------------------------------------------------------

% ------------------------------------------------------------------------------
%                             Теорема о интервале занятости
% ------------------------------------------------------------------------------
\section{Теорема о корректности метода интервала занятости}

В этой и последующих главах приведены основные схемы доказательств теорем корректности метода интервала занятости, корректности оценки наихудшего времени ожидания для моделей FP- и EDF-планирования.
  Полные формализованные доказательства теорем выполненные в системе Coq находятся в репозитории: \url{https://gitlab.mpi-sws.org/sbozhko/rt-proofs}.

В данной главе дана схема доказательства  теоремы о корректности метода интервала
  занятости. Основная задача заключалась в том, чтобы показать корректность метода
  для любой модели планирования,  которая удовлетворяет необходимым требованиям.
  Для доказательства предлагается следующий подход. Рассматривается произвольная модель планирования,
  введены некоторые ограничения на рассматриваемую модель и доказана теорема о корректности
  метода интервала занятости с данными ограничениями. После этого доказанную теорему
  можно использовать для получения доказательств корректности оценок наихудшего
  времени ожидания задачи для моделей планирования, которые удовлетворяют ограничениям,
  введёным для теоремы о методе интервала занятости (главы 3 и 4). В случае достаточно гибких
  ограничений возможно получить доказательство корректности оценок для более широкого
  спектра моделей планирования.

\subsection{Определения}

В этом разделе описаны функции, существование которых предполагается для модели планирования, к которой применяется метод интервала занятости. При этом описываются сигнатуры и некоторые свойства этих функций, в то время как за их реализацию отвечает соответствующая модель. Эти функции используются в дальнейших доказательствах.

Пусть существует функция $arr\_seq: time -> list(Job)$, которая принимает на вход
  момент времени $t$ и возвращает список работ, которые появились в этот момент времени.

Пусть существует функция-планировщик, которая действует из времени в
  работы ($sched: time -> option(Job)$). Мы говорим, что работа $j$ запланирована
  в момент времени $t$, если $sched(t) = Some(j)$. Введём следующее сокращение:
  $is\_sched\_at(j,t) = (sched(t) = Some(j))$.

Заметим, что функции $arr\_seq$ и $sched$ должны обладать некоторыми ограничивающими свойствами.
  Например, любая работа, которая запланирована в момент времени $t$,
  должна была ранее появиться в момент времени $t'$ ($\leq t$), или более формально, $\exists t', t' \leq t \wedge j \in arr\_seq (t')$.


Во всех доказательствах и определениях предполагается, что существует множество
  задач анализируемой системы реального времени, обозначаемое $ts$,
  а также рассматривается задача $tsk \in ts$, для которой необходимо
  найти оценку наихудшего времени ожидания. Предполагается, что любая задача из $tsk$
  обладает некоторыми естественными свойствами, например, число работ, которые может
  произвести задача $tsk$ за единицу времени, должно быть ограничено.

Как было сказано в главе 1, предполагается, что работы состоят из невытесняемых сегментов.
  Предполагается, что известна длина последнего невытесняемого сегмента $q^{last}$ любой работы.
  После того, как работа $j$ получит $c_{j} - q_j^{last} + \epsilon$ единиц сервиса,
  она войдёт в последний, невытесняемый, сегмент, а значит станет невытесняемой
  до своего полного завершения. Обозначим количество сервиса, которое должна получить работа для того,
  чтобы стать невытесняемой, как $lock\_in\_service(j) = c_{j} - q_j^{last} + \epsilon$.

\textsc{Определение 5.}
\textit{Число $R$ называется наихудшим временем ожидания для задачи $tsk$, если
  любая работа $j$ задачи $tsk$ завершается за $R$ единиц времени.}

Данное определение, записанное на языке Coq, представлено на листинге 1.

\begin{listing}
\begin{pyglist}[numbers=none,numbersep=5pt, fontsize=\small]
  Definition is_response_time_bound_of_task tsk R :=
    forall j,
      job_task j = tsk ->
      job_completed_by j (job_arrival j + R).
\end{pyglist}
\caption{Определение наихудшего времени ожидания.}
\label{lst:def:rtb}
\end{listing}


После того, как работа появилась, на неё может оказывать влияние окружение (например,
  другие работы с более высоким приоритетом, работы с более низким приоритетом могут
  вызывать блокировку, также существует множество других модификаций, в
  которых причины помех могут не быть работами [blackouts, jitter, budgets, locks]).
  Любое из этих влияний откладывает выполнение работы на некоторое время.
  Vы называем такое влияние помехой (interference).

Пусть существует функция $i$, которая описывает помехи, испытываемые любой работой. Она
  принимает на вход работу $j$ и момент времени $t$ и отвечает
  на вопрос, испытывает ли работа $j$ помехи в момент времени $t$.

Введем суммарную функцию помех, которая является суммой значений $i(j,t)$
  в точках из интервала $[t_1, t_2)$ ($cumul\_i(j,t_1,t_2) = \sum_{t = t_1}^{t_2} i(j,t)$).
  Формальное определение, записанное на языке Coq, представлено на листинге 2.


\begin{listing}
\begin{pyglist}[numbers=none,numbersep=5pt, fontsize=\small]
  Variable i: Job -> time -> bool.
  Definition cumul_i j t1 t2 :=
    \sum_(t1 <= t < t2) i j t.
\end{pyglist}
\caption{Определение функции суммарных помех.}
\label{lst:theorem2}
\end{listing}

Пусть существует функция $w$, которая описывает количество помех,
  генерируемых окружением в каждый момент времени. Обычно заранее известно, какие
  элементы окружения могут вызвать помехи. Поэтому мы предполагаем, что существует
  функция, которая может вычислить, какое количество помех работа $j$ получила в
  момент времени $t$. Например, рассмотрим работу $j$. Пусть в момент времени $t$
  появилась работа $j_{hp}$ с более высоким приоритетом, тогда $w(j,t) = c_{j_{hp}} + ..$.
  Также введём суммарную функцию $cumul\_w(j,t_1,t_2) := \sum_{t = t_1}^{t_2} w(j,t)$,
  которую будем называть суммарной нагрузкой.
  Формальное определение, записанное на языке Coq, представлено на листинге 3.

\begin{listing}
\begin{pyglist}[numbers=none,numbersep=5pt, fontsize=\small]
  Variable w: Job -> time -> time.
  Definition cumul_w j t1 t2 :=
    \sum_(t1 <= t < t2) w j t.
\end{pyglist}
\caption{Определение функции суммарной нагрузки.}
\label{lst:theorem2}
\end{listing}

Таким образом функция $w(\cdot,\cdot)$ учитывает все
  появившиеся помехи, а $i(\cdot,\cdot)$ описывает, когда эти помехи \textit{тратятся}.

\textsc{Определение 6.}
\textit{Мы говорим, что $t$ является тихим временем для работы $j$, если суммарное
  количество помех в момент времени $t$ равно суммарному количеству нагрузки в момент
  времени $t$, и задание не является ожидающим в момент времени $t$, если появилась
  ранее.
}

Данное определение состоит из двух частей. С одной стороны, все помехи, которые появились
  до момента времени $t$ должны быть потрачены в момент времени $t$ (суммарное количество
  помех равно суммарной нагрузке). Поэтому, в момент времени $t$ нет более нагрузки,
  которая появилась до момента $t$, и которая могла бы вызвать помехи для работы $j$
  в будущем. С другой стороны, работа $j$ не должна находиться в ожидании, если она
  появилась до момента времени $t$. Формальное определение, записанное на языке Coq, представлено на листинге 4.
\begin{listing}
\begin{pyglist}[numbers=none,numbersep=5pt, fontsize=\small]
  Definition quiet_time (j: Job) (t: time) :=
    cumul_i j 0 t = cumul_w j 0 t /\
    ! (arrived_before j t /\ ! job_completed_by j t).
\end{pyglist}
\caption{Определение <<тихого>> времени}
\label{lst:theorem2}
\end{listing}

\textsc{Определение 7.}
\textit{Интервал $[t_1, t_{busy})$ называется префиксом интервала занятости,
  если интервал (a) не пустой, (b) начинается с тихого
  времени, (c) остается не тихим и (d) содержит появление работы $j$.
}

% Данное определение, записанное на языке Coq, представлено на листинге 5.

\begin{listing}
\begin{pyglist}[numbers=none,numbersep=5pt, fontsize=\small]
  Definition busy_interval_prefix (j: Job)
                                  (t1 t_busy: time) :=
    t1 < t_busy /\
    quiet_time j t1 /\
    (forall t, t1 < t < t_busy -> ! quiet_time j t) /\
    t1 <= job_arrival j < t_busy.
\end{pyglist}
\caption{Определение префикса интервала занятости}
\label{lst:theorem2}
\end{listing}

\textsc{Определение 8.}
\textit{Интервал $[t_1,t_2)$ является интервалом занятости,
  если $[t_1,t_2)$ --- префикс интервала занятости, а $t_2$ является тихим временем.
}

% Данное определение, записанное на языке Coq, представлено на листинге 6.

\begin{listing}
\begin{pyglist}[numbers=none,numbersep=5pt, fontsize=\small]
  Definition busy_interval (j: Job) (t1 t2: time) :=
    busy_interval_prefix j t1 t2 /\
    quiet_time j t2.
\end{pyglist}
\caption{Определение интервала занятости}
\label{lst:theorem2}
\end{listing}

Такое определение интервала занятости имеет несколько преимуществ перед определениями
  приведенными в разделе 1.2. Такое определение обладает всеми необходимыми свойствами,
  упомянутыми в разделе 1.2, но кроме того, как будет видно в главах 3 и 4, такое
  определение возможно использовать как для случая FP\-/планирования,
  так и для случая EDF\-/планирования, также это определение возможно использовать
  для любой модели JLFP-планировщика.

\subsection{Необходимые предположения о системе}

В этом разделе описаны необходимые предположения о функциях $i$ и $w$.

\textsc{Предположение 1.}
\textit{Мы говорим, что функция $i$ является сохраняющей работу для задачи $tsk$,
  если для любой работы $j$ из задачи $tsk$ и для любого времени $t$ из интервала
  занятости работы $j$ выполняется одна из двух опций: $i(j, t) = true$ или работа
  $j$ выполняется в момент времени $t$. Другими словами, работа должна выполняться,
  если не испытывает никаких помех. }

Данное предположение, записанное на языке Coq, представлено на листинге 7.

\begin{listing}
\begin{pyglist}[numbers=none,numbersep=5pt, fontsize=\small]
  Definition work_conserving interference tsk :=
    forall j t1 t2 t,
      job_task j = tsk ->
      busy_interval j t1 t2 ->
      t1 <= t < t2 ->
      ! i j t <-> job_scheduled_at j t.
\end{pyglist}
\caption{Определение сохранения работы.}
\label{lst:theorem2}
\end{listing}


\textsc{Предположение 2.}
\textit{Мы говорим, что интервалы занятости для задачи $tsk$ ограничены константой $L$,
  если для любой работы $j$ задачи $tsk$ существует интервал занятости с длинной не более, чем $L$. }

Данное предположение, записанное на языке Coq, представлено на листинге 8.


\begin{listing}
\begin{pyglist}[numbers=none,numbersep=5pt, fontsize=\small]
  Definition busy_intervals_are_bounded_by tsk L :=
    forall j,
      job_task j = tsk ->
      exists t1 t2,
        t2 - t1 <= L /\
        busy_interval j t1 t2.
\end{pyglist}
\caption{Определение ограниченности интервалов. }
\label{lst:theorem2}
\end{listing}

\textsc{Предположение 3.}
\textit{Мы говорим, что помехи задачи $tsk$ ограничены функцией $IBF_{tsk}$,
  когда для любой работы $j$ задачи $tsk$ и для любого момента времени $t_1 + R \in [t_1, t_2)$,
  при условии, что работа $j$ не завершена в момент времени $t_1 + R$,
  суммарные помехи работы $j$ в интервале $[t_1, t_1 + R)$ меньше, чем $IBF_{tsk}(A, R)$. }

 Рассмотрим предположение 3 подробнее. Во-первых,
  нет необходимости рассматривать всевозможные интервалы,
  достаточно того, чтобы функция $IBF_{tsk}$ ограничивала суммарные помехи только в интервале
  $[t_1, t_1 + R)$, где $t_1$ --- начало интервала занятости соответствующей работы.
  Во-вторых, для того, чтобы получить более слабую гипотезу, требуется, чтобы $IBF_{tsk}$
  ограничивала помехи только в том случае, если рассматриваемая работа не завершена.
  Так как функция помех не имеет смысла после завершения работы, можно положить,
  что в этом случае функция, ограничивающая помехи работы, может принимать произвольные значения.
  Кроме того, функция $IBF_{tsk}$ зависит от дополнительного параметра,
  относительного времени прибытия работы,это сделано для большей гибкости в выборе функций $IBF_{tsk}$.
  В случае EDF\-/планирования этот параметр играет ключевую роль. Формальное
  определение предположения 3 на языке Coq приведена на листинге 9.

\begin{listing}
\begin{pyglist}[numbers=none,numbersep=5pt, fontsize=\small]
  Definition job_cumulative_interference_is_bounded_by tsk
                                                       IBF :=
    forall t1 t2 R j,
      busy_interval j t1 t2 ->
      t1 + R < t2 ->
      job_task j = tsk ->
      ~~ job_completed_by j (t1 + R) ->
      cumulative_interference j t1 (t1 + R)
          <= IBF (job_arrival j - t1) R.
\end{pyglist}
\caption{Определение функции ограничивающей помехи работы. }
\label{lst:theorem2}
\end{listing}

В случаях, когда для анализирования оценки наихудшего времени ожидания была выбрана функция $IBF_{tsk}(A,\cdot)$,
  зависящая от параметра, приходится вычислять функцию $IBF_{tsk}(A,\cdot)$ для всевозможных $A$.
  Однако для использования алгоритма на практике необходимо сократить пространство перебора этого параметра.
  То есть, необходимо выбрать некоторое подмножество значений $SP$, таких, что значения
  функции $IBF_{tsk}(A,\cdot)$ для параметров $A$ из этого пространства поиска давали
  всю необходимую информацию о $IBF_{tsk}$ в целом. Оказывается, что
  это возможно сделать, используя довольно простые рассуждения.

Пусть имеется два параметра $A_1$ и $A_2$. Если возможно доказать, что
  $\forall x \ IBF_{tsk}(A_1,x) = IBF_{tsk}(A_2, x)$, то любое вхождение $IBF_{tsk}(A_2, \cdot)$
  можно заменить на $IBF_{tsk}(A_1,\cdot)$.
  Таким образом, $A_2$ можно вычеркнуть из пространства поиска.
  Кроме того, параметр $A$ является относительным временем прибытия работы,
  а значит, должен быть строго меньше, чем $L$.

Определим пространство поиска формально.

\textsc{Определение 9.}
\textit{Параметр $A$ находится в пространстве поиска, если $A = 0 $ или $A < L$ и $IBF_{tsk}(A - \epsilon, \cdot) \neq IBF_{tsk}(A,\cdot)$, где $IBF_{tsk}$ --- функция, для которой выполняется предположение 3. }

Введём выражение, вычислив которое, можно получить оценку наихудшего время ожидания задачи.

\textsc{Предположение 4.}
\textit{Пусть существует константа $R$ такая, что для любого $A$ из пространства
  поиска существует $F$ такое, что
  $A + F = (C_{tsk} - q_{tsk}^{last} +\epsilon) + IBF_{tsk}(A, A + F)$ и $F + (q_{tsk}^{last} - \epsilon) \leq R$,
  где $IBF_{tsk}$ удовлетворяет предположению 3. }

Далее будет введено предположение о последовательсти работ. Для этого введём
  несколько предварительных определений. Суммарную стоимость всех работ из задачи,
  которые появились в промежутке времени $[t_1, t_2)$, будем называть нагрузкой задачи
  в промежутке $[t_1, t_2)$, которую обозначим как $task\_workload(tsk, [t_1, t_2))$.
  Аналогичным образом определим функцию $task\_service(tsk, [t_1, t_2))$,
  которая является суммой всего сервиса, полученного работами из задачи $tsk$ в промежутке
  времени $[t_1, t_2)$.

Введём помехи для \textit{задачи} $(task\_i(tsk,t))$. Будем говорить, что задача $tsk$ испытывает помехи
  в момент времени $t$, если в этот момент времени существует работа $j$ из задачи $tsk$,
  для которой $i(j,t) = true$ и в момент времени $t$ не выполняется никакая из работ из задачи $tsk$.
  Второе условие необходимо для того, чтобы исключить ситуацию, когда существуют две работы из одной и той же
  задачи и одна создаёт помехи другой.

Для случая с последовательными работами можно рассмотреть другой вид функции, ограничивающий
  помехи для задачи, а не для работы. Поэтому далее предполагается, что существует
  функция $IBF(\cdot, \cdot)$, которая ограничивает суммарные помехи задачи.

Во второй части доказательства вводится предположение о \textit{последовательности работ}.
  Это предположение говорит, о том, что две работы из одной задачи будут выполняться строго в порядке появления.
  После введения этого предположения некоторые $i$ и $w$ станут некорректными.
  Поэтому необходимо ввести дополнительное ограничение на $i$ и $w$.

\textsc{Предположение 5.}
\textit{Для интервала занятости $[t_1, t_2)$ любой работы $j$ из задачи $tsk$ выполняется следующее условие:
  все суммарные помехи задачи $tsk$ в интервале $[0, t_1)$ равны суммарной нагрузке задачи в том же интервале. }

Данное предположение, записанное на языке Coq, представлено на листинге 10.

\begin{listing}
\begin{pyglist}[numbers=none,numbersep=5pt, fontsize=\small]
  Definition task_consistensy_of_i_w :=
    forall j t1 t2,
      job_task j = tsk ->
      busy_interval j t1 t2 ->
      task_workload 0 t1 = task_service 0 t1.
\end{pyglist}
\caption{Определение согласованности функций $i$ и $w$. }
\label{lst:theorem2}
\end{listing}

После введения дополнительной информации о виде $i$ и $w$ становится
  возможным уточнить вид предположений, в которых используется функция $IBF_{tsk}$.

\textsc{Предположение 6.}
\textit{Данное предположение аналогично предположению 3, однако теперь $IBF_{tsk}$ должна
  ограничивать помехи задачи $tsk$.}

Определение предположения 6, записанное на языке Coq приведено на листинге 11.

\begin{listing}
\begin{pyglist}[numbers=none,numbersep=5pt, fontsize=\small]
  Definition task_interference_is_bounded_by tsk IBF :=
    forall t1 t2 R j,
      busy_interval j t1 t2 ->
      t1 + R < t2 ->
      job_task j = tsk ->
      ~~ job_completed_by j (t1 + R) ->
      cumulative_i_task tsk j t1 (t1 + R)
          <= IBF (job_arrival j - t1) R.
\end{pyglist}
\caption{Определение функции ограничивающей помехи задачи. }
\label{lst:theorem2}
\end{listing}


В условиях предположения 5, функция $C_{tsk}AC_{tsk}(A + \epsilon) - C_{tsk} + IBF_{tsk}(A, \cdot)$,
  где $IBF_{tsk}(A, \cdot)$ --- функция удовлетворяющая предположению 6,
  является функцией для которой выполняется предположение 3.
  Пространство поиска параметра определено для функции, удовлетворяющей предположению 3,
  поэтому для того, чтобы говорить о пространстве поиска для функцию, удовлетворяющей
  предположению 6, нужно модифицировать её способом, описанным выше.
  В лемме 12 показано, что такое преобразование действительно не нарушает пространства поиска.

\textsc{Предположение 7.}
\textit{Пусть существует константа $R$ такая, что для любого $A$ из пространства
  поиска существует $F$ такое, что:
  $A + F = (AC_{tsk}(A + \epsilon) - q_{tsk}^{last}) + IBF_{tsk}(A, A + F)$ и $F + (q_{tsk}^{last} - \epsilon) \leq R$,
  где $IBF_{tsk}(\cdot, \cdot)$ удовлетворяет предположению 6. }


\subsection{Доказательство теоремы о корректности метода интервала занятости}

Доказательство проводится в два этапа: первый этап посвящен доказательству случая, когда последовательность
  работ из одной задачи не предполагается, и уточненное доказательство, когда последовательность
  работ предполагается.

Перейдём к первому этапу доказательства.

В леммах 1, 2 и 3  предполагается, что существует работа $j$ и соответствующий ей интервал занятости $[t_1, t_2)$.

\textsc{Лемма 1. }
\textit{Работа $j$ будет завершена к моменту времени $t_2$. }

\textsc{Доказательство.}
  Из определения интервала занятости известно, что $t_2$ --- тихое время, а это
    значит, что работа $j$ не является ожидающей в момент времени $t_2$.
    Но интервал занятости содержит появление работы $j$. Значит, работа $j$
    появилась раньше $t_2$. То, что работа появилась ранее $t_2$,
    но не является ожидающей в момент времени $t_2$, означает, что работа $j$
    завершилась в момент времени $t_2$.
$\square$

\textsc{Лемма 2. }
\textit{Для любых двух моментов времени $t$ и $t + \Delta$ таких, что $t_1 \leq t \leq t + \Delta \leq t_2$, выполняется равенство $service\_during (j, t, t + \Delta)$ $+$ $cumul\_i(j, t, t + \Delta) = \Delta$. }

\textsc{Доказательство.}
  Раскроем определения термов $service\_during$ и $cumul\_i $.
  Перепишем $\Delta$ как $\sum_{\_ = t}^{t+\Delta}1$, тогда получим:
    $\sum_{x = t}^{t+\Delta} is\_sched\_at(j,x) + \sum_{x = t}^{t+\Delta} i(j,x) = \sum_{\_ = t}^{t+\Delta} 1 $.
  Объединим суммы, находящиеся слева от знака равенства:
    $\sum_{x = t}^{t+\Delta} is\_sched\_at(j,x) + i(j,x) = \sum_{\_ = t}^{t+\Delta} 1 $.
  Для доказательства этого равенства достаточно показать, что для любого $x \in [t, t + \Delta)$ выполняется:
    $is\_sched\_at(j,x) + i(j,x) = 1$.
  Последнее равенство следует из предположения о сохранении работы, то есть предполагается, что в любой момент времени $x \in [t_1, t_2)$ либо работа $j$ исполняется, либо $i(j,t) = true$. Известно, что $x \in [t_1, t_2)$, поэтому возможно
  воспользоваться предположением о сохранении работы, что и доказывает лемму. $\square$

\textsc{Лемма 3.}
\textit{Пусть существует константа $\Delta$ такая, что \\ $ lock\_in\_service(j)$ $+$ $cumul\_i(j, t_1, t_1 + \Delta) $ $\leq$ $ \Delta$. Тогда $lock\_in\_service(j) \leq service\_during(j, 0, t_1 + \Delta)$, другими словами, работа $j$ получила достаточно сервиса для того, чтобы войти в последний, невытесняемый, сегмент. }

\textsc{Доказательство.} Разделим доказательство на два случая.

Рассмотрим случай, когда \textit{$t_2 < t_1 + \Delta$}. В этом случае интересующий нас момент времени находится вне интервала занятости. Воспользуемся леммой 1. Так как работа $j$ завершена в момент времени $t_2$, то $j$ также завершена и в момент времени $t_1 + \Delta$. Это утверждение эквивалентно следующему: $service\_during(j, 0, t_1 + \Delta) = C_{j}$. Другими словами: $lock\_in\_service(j) \leq C_{j}$, из определения $lock\_in\_service$ легко видеть, что неравенство выполняется.

Рассмотрим случай, когда \textit{$t_1 + \Delta \leq t_2$}. Для доказательства заключения леммы воспользуемся транзитивностью отношения ($\leq$). Получим следующую цепочку неравенств:
  $lock\_in\_service(j) $ $\leq$ $ \Delta$ $-$ $cumul\_i(j, t_1, t_1 + \Delta)$ $\leq$ $service\_during(j, 0, t_1 + \Delta)$.
  Первое из неравенств выполняется очевидным образом, достаточно просто перенести терм
  $cumul\_i(j, t_1, t_1 + \Delta)$ налево, чтобы получить одно из предположение леммы.
  Для доказательства второго неравенства сузим суммирование сервиса до интервала $[t_1, t_1 + \Delta)$.
  Получим, что $ \Delta$ $-$ $cumulative\_i(j, t_1, t_1 + \Delta)$ $\leq$ $service\_during(j, t_1, t_1 + \Delta)$.
  Далее нужно перенести $\Delta$ направо и воспользоваться леммой 2. $\square$

Далее будут доказаны леммы, которые обосновывают возможность сокращения пространства поиска.

\textsc{Лемма 4.}
\textit{Для любого $A < L $ существует константа $A_{sp}$ такая, что $ A_{sp} \leq A$, $IBF_{tsk}(A_{sp}, \cdot) = IBF_{tsk}(A, \cdot)$ и $A_{sp}$ находится в пространстве поиска.}

\textsc{Доказательство.} Для доказательства существования константы $A_{sp}$ достаточно предоставить алгоритм её построения. Получить $A_{sp}$ можно с помощью последовательности шагов, представленной ниже.
    \begin{enumerate}
        \item Вначале положить $A_{sp} = A$.
        \item Проверить, правда ли, что $IBF_{tsk}(A_{sp}, \cdot) = IBF_{tsk}(A, \cdot)$ и $A_{sp}$ находится в пространстве поиска.
        \item Если ответ положителен, значит, $A_{sp}$ успешно найдено. Если нет, то уменьшить $A_{sp}$ на 1 и вернуться к шагу 2. $\square$
    \end{enumerate}


\textsc{Лемма 5.}
\textit{Рассмотрим две константы $A_{sp}$ и $F_{sp}$ такие, что $A_{sp} + F_{sp} = IBF(A_{sp}, A_{sp} + F_{sp})$. Тогда для любой константы $A$ такой, что $A_{sp} \leq A \leq A_{sp} + F_{sp}$ и $IBF(A, \cdot) = IBF(A_{sp},\cdot)$, существует константа $F$, такая что $A_{sp} + F_{sp} = A + F$, $F \leq F_{sp}$ и $A + F = IBF(A, A + F)$.}

\textsc{Доказательство.} Пусть $F = A_{sp} + F_{sp} - A$. После этого легко проверить, что для F выполняются все свойства, указанные в формулировке леммы. $\square$


Далее приведено подробное доказательство теоремы о корректности метода интервала занятости.
  В начале, явно перечислим все необходимые предположения.

Пусть существуют описанные выше функции $i$ и $w$ и пусть выполнено условие сохранения работы (предположение 1).
  Все интервалы занятости ограничены некоторой константой $L$ (предположение 2).
  Также существует функция, ограничивающая помехи любой работы задачи $tsk$ (предположение 3).
  А так же существует $R$, которая является решением уравнения для нахождения наихудшего
  времени ожидания задачи (предположение 4).

\textsc{Теорема 6.}
\textit{$R$ является оценкой наихудшего времени ожидания задачи $tsk$. }

\textsc{Доказательство.}
  По определению оценки наихудшего времени ожидания $R$ должно обладать следующим свойством:
    любая работа $j$ задачи $tsk$ должна завершаться к моменту времени $a_j + R$.
  Поэтому, пусть существует произвольная работа $j$ задачи $tsk$, докажем,
    что она будет завершена к моменту времени $a_j + R$.
  По предположению 2 существует соответствующий интервал занятости $[t_1, t_2)$ с длинной меньше $L$.
  Обозначим относительное время прибытия $a_j - t_1$ как $A$. Заметим, что
  $A$ не обязательно находится в пространстве поиска. Поэтому невозможно напрямую
    воспользоваться предположением 4. Однако леммой 4 гарантируется, что
  существует $A_{sp}$ такое что: $A_{sp} \leq A$,
  $IBF_{tsk}(A_{sp},\cdot) = IBF_{tsk}(A,\cdot)$ и $A_{sp}$ принадлежит пространству поиска.
  Тогда по предположению 4, существует $F_{sp}$, такое, что
    $A_{sp} + F_{sp} = C_{tsk} - (q_{tsk}^{last} - \epsilon) + IBF_{tsk}(A_{sp}, A_{sp} + F_{sp})$ и
    $F_{sp} + (q_{tsk}^{last} - \epsilon) \leq R$. Далее рассмотрим три случая:

\textit{Рассмотрим случай, когда $t_2 \leq t_1 + (A_{sp} + F_{sp})$.}
  В данном случае, решение уравнения оказалось настолько большим, что вышло за границы
  интервала занятости. Но из леммы 1 известно, что работа завершается к концу интервала
  занятости. Покажем, что $t_2 \leq a_j + R$. Для этого рассмотрим следующую последовательность
  неравенств: $t_2 \leq t_1 + (A_{sp} + F_{sp}) \leq t_1 + A + F_{sp} \leq a_{j} + R$.
  Первое неравенство является предположением. Второе неравенство выполняется из-за того,
  что $A_{sp} \leq A$. Последнее неравенство можно получить воспользовавшись тем фактом,
  что $A = (a_{j} - t_1)$, а затем $F_{sp} \leq R$. Таким образом: $t_2 \leq a_j + R$.
  Работа $j$ завершена в момент времени $t_2$, а следовательно, завершена и в  момент времени $a_j + R$.

\textit{Рассмотрим случай, когда $t_1 + (A_{sp} + F_{sp}) < t_2$ и $A \leq A_{sp} + F_{sp}$.}
    Напомним, что по лемме 5 существует $F$, такое что: $A_{sp} + F_{sp} = A + F$, $F \leq F_{sp}$ и
      $A + F = C_{tsk} - (q_{tsk}^{last} - \epsilon) + IBF_{tsk}(A, A + F)$.
    В качестве промежуточного шага, докажем, что $t_1 + (A + F) + (q_{j}^{last} - \epsilon) \leq a_{j} + R$.
    Для этого рассмотрим следующую цепочку неравенств:
    $t_1 + (A + F) + (q_{j}^{last} - \epsilon) \leq (a_j + (F + (q_{j}^{last} - \epsilon))) \leq
      (a_j + (F + (q_{tsk}^{last} - \epsilon))) \leq a_{j} + R$.
    Если работа $j$ в момент времени $t_1 + (A + F)$ получит $lock\_in\_service(j)$ сервиса,
      то она станет невытесняемой, а это значит в худшем случае, она завершится через
      $(q_{j}^{last} - \epsilon)$ единиц времени.
    Для доказательства этого факта воспользуемся леммой 3. Получим, что работа
      в момент времени $t_1 + (A + F)$ имеет $lock\_in\_service(j)$ сервиса, а значит,
      она вошла в невытесняемую область. Это, в свою очередь означает, что работа завершилась
      к моменту времени $t_1 + (A + F) + (q_{j}^{last} - \epsilon)$, что меньше, чем $a_j + R$.

\textit{Рассмотрим случай, когда $t_1 + (A_{sp} + F_{sp}) < t_2$ и $A_{sp} + F_{sp} < A$.}
    Покажем, что такого не может быть.
    По условию имеем, что $A < L$. Так как $A = a_j - t_1$, $a_j \in [t_1, t_2)$ и $t_2 - t_1 < L$.
    Далее воспользуемся леммой 3, для того чтобы получить следующий факт:
      $lock\_in\_service(j) \leq service(j, t_1 + (A_{sp} + F_{sp}))$.
    Также из определения $lock\_in\_service (j)$ понятно, что $lock\_in\_service( j) > 0$. Изменим
      полученную гипотезу: $0 < service(j, t_1 + (A_{sp} + F_{sp}))$.
    Однако также можно показать, что $service(j, t_1 + (A_{sp} + F_{sp})) = 0$. Докажем, что
      в момент времени $t_1 + (A_{sp} + F_{sp})$ работа $j$ ещё не появилась, то есть $t_1 + (A_{sp} + F_{sp}) < a_j$.
    Перепишем $a_j$ как $t_1 + (a_j - t_1)$ или $t_1 + A$.
    Тогда нужно доказать, что: $(t_1 + (A_{sp} + F_{sp})) < t_1 + A$, но это наше предположение.
    Таким образом, мы получили: $0 < 0$, что является противоречием.
 $\square$

\subsection{Доказательство теоремы о корректности метода интервала занятости для случая последовательных работ}

Перейдём ко второму этапу доказательства, а именно, к доказательству уточнённого случая,
  воспользуемся теоремой о корректности метода интервала занятости. Однако
  некоторые предположения для данной теоремы отличаются от тех, что используются
  в версии теоремы без предположения последовательности работ. В этом разделе будет доказано,
  что новые предположения можно свести к предыдущим, а значит, воспользоваться уже доказанной теоремой,
  для получения доказательства для этой теоремы.

Основное отличие заключается в следующем: рассмотрим некоторую работу $j$ задачи $tsk$.
  Существует интервал занятости $[t_1,t_2)$ работы $j$. Вводится специальное предположение о том,
  что все работы из задачи $tsk$, должны быть завершены к моменту времени $t_1$, если
  появились до момента времени $t_1$. Далее, мы знаем, что работы из одной задачи
  выполняются последовательно, то все помехи работе $j$ от работ задачи $tsk$
  ограничены максимумом работ, которые могли бы появиться в интервале $[t_1, t_1 + A)$.
  Так как известна такая функция, как $AC_{tsk}$, возможно явно вычислить оценку сверху.

Далее предполагается, что остались те же функции $i$ и $w$. Предполагается, что работы последовательны.
  А также то, что выполняются предположения 1, 2, 5, 6, 7. Далее будет доказано,
  что в данных условиях возможно доказать, что выполняются предположения 3 и 4,
  а значит, справедлива теорема 6.

В леммах 7 и 8 рассматриваются две работы $j$ и $j_o$ задачи $tsk$. Также предполагается, что существует интервал занятости $[t_1, t_2)$ для работы $j$. Тогда справедливы следующие леммы.

\textsc{Лемма 7.}
\textit{Пусть работа $j_o$ появилась до момента времени $t_1$. Тогда она завершится до момента времени $t_1$. }

\textsc{Доказательство.} Следует прямо из предположения 5 о согласованности функций $i$ и $w$.
  Из предположения 5 следует то, что суммарная нагрузка задачи и суммарный сервис
  задачи будут равны в момент времени $t_1$. А это значит, что все работы задачи $tsk$,
    которые появились раньше $t_1$ получили достаточно сервиса, чтобы считаться завершёнными. $\square$

\textsc{Лемма 8.}
\textit{Пусть работа $j_o$ оказалась ожидающий в какой-то момент времени $t \geq t_1$. Тогда момент появления работы $j_o$ лежит в отрезке времени $[t_1, t]$. }

\textsc{Доказательство.} Докажем от противного. Пусть работа $j_o$ появилась не в интервале $[t_1, t]$.
  $j_o$ не может появиться позже $t$, так как в момент $t$ уже является ожидающей.
  С другой стороны, пусть работа  $j_o$ появилась раньше $t_1$. Но это противоречит с лемме 7.
  $\square$

Далее будет получена оценка суммарного количества помех работы через суммарное количество
  помех задачи. Рассмотрим произвольную работу $j$ задачи $tsk$ и соответствующий
  интервал занятости $[t_1, t_2)$. Также обозначим $a_j - t_1$ как $A$. Выберем
  произвольное время внутри интервала занятости $t_1 + x \in [t_1, t_2)$,
  в котором работа $j$ не завершена. Тогда выполнены следующие три леммы.

\textsc{Лемма 9.}
\textit{Суммарные помехи работы $j$ в интервале $[t_1, t_1 + x)$ не больше суммы
    суммарных помех задачи в интервале $[t_1, t_1 + x)$ и
    суммарной нагрузки задачи в интервале $[t_1, t_1 + A + \epsilon)$
    минус стоимость рассматриваемой задачи
  Или формально,
   $\sum_{t = t_1}^{t_1 + x} i(j,t) \leq
     \sum_{t = t_1}^{t_1 + x} task\_i(t) + (task\_workload(tsk, [t_1, t_1 + A + \epsilon)) - C_{j})$ }

\textsc{Доказательство.}
  Далее приведено неформальное доказательство, которое, однако, сохраняет основную идею
  оригинального доказательства. Разница правой и левой частей состоит в том, что
  левый терм ограничивает все помехи работы (в том числе и помехи от работ из той же задачи).
  Справа стоит сумма термов, где
    первый терм ограничивает помехи работы, полученные из других задач,
    а второй терм ограничивает помехи работы, полученные от работ из той же задачи.
  Однако терм $(task\_workload(tsk, [t_1, t_1 + A + \epsilon)) - C_{j})$
    имеет изменённый вид так как суммируется не по всему интервалу $[t_1, t_1 + x)$,
    а только по $[t_1, t_1 + A + \epsilon)$.
  Таким образом, для доказательства теоремы необходимо показать,
    что терм $(task\_workload(tsk, [t_1, t_1 + A + \epsilon)) - C_{j})$
    действительно ограничивает все помехи на интервале $[t_1, t_1 + x)$.
  С одной стороны, работы из задачи $tsk$, которые появились до момента времени $t_1$,
    не могут повлиять на задачу $j$, так как уже завершены (по лемме 7).
  А с другой стороны, все работы, которые пришли позже $t_1 + A + \epsilon$ тоже
    не могут повлиять на работу $j$, так как пришли позже, и, из-за предположения
    о последовательности работ, будут запланированы после завершения работы $j$.
  Остаётся только сказать, что $(task\_workload(tsk, [t_1, t_1 + A + \epsilon))$
    учитывает стоимость всех работ, которые появились в интервале $[t_1, t_1 + A + \epsilon)$
    (включая стоимость работы $j$). Её стоимость необходимо вычесть. $\square$

Выражение $(task\_workload(tsk, [t_1, t_1 + A + \epsilon))$ является выражением,
  которое можно вычислить только для конкретного расписания. Нам же нужна оценка сверху,
  которая будет выполняться для любого расписания.

\textsc{Лемма 10.}
\textit{Выполняется следующее неравенство: \\
$task\_workload(tsk, [t_1, t_1 + A + \epsilon)) - C_{j} \leq C_{tsk}AC_{tsk}(A + \epsilon) - C_{tsk}.$
}

\textsc{Доказательство.} Это неравенство сложнее, чем тривиальное $a - b \leq c - d$ при $ a \geq b$ и $b \leq d$.
  Основной результат этого доказательства состоит в том, что показано,
  что неравенство выполняется несмотря на то, что $C_{j} \leq C_{tsk}$.
  Выражение $task\_workload(tsk, [t_1, t_1 + A + \epsilon))$ равно
    общей стоимости всех работ из задачи $tsk$, которые появились в
    отрезке времени $[t_1, t_1 + A]$. Из этой суммы вычтена стоимость работы $j$.
  В левой стороне неравенства стоит общая стоимость всех работ из задачи $tsk$, кроме стоимости $j$.
  С правой стороны аналогичная ситуация, $C_{tsk}AC_{tsk}(A + \epsilon)$ ограничивает
    максимальную стоимость всех работ из задачи $tsk$, которые могут появиться
    в любом интервале длины $A + \epsilon$. Из этой стоимости вычитается стоимость
    одного из появлений. Таким образом, стоимость всех работ, которые появились
    в интервале длины $A + \epsilon$, кроме одной,
   ограничивает число, которое равно максимальной стоимости всех работ,
    которые могут появиться в интервале длины $A + \epsilon$, минус одно появление. $\square$

\textsc{Лемма 11.}
\textit{Суммарное количество помех в $[t_1, t_1 + x)$ для работы $j$ меньше либо равно,
 чем сумма $C_{tsk}AC_{tsk}(A + \epsilon) - C_{tsk}$ и
   суммарного количества помех в $[t_1, t_1 + x)$ для задачи $tsk$.
 Формально,
   $\sum_{t = t_1}^{t_1 + x} i(j,t)
     \leq C_{tsk}AC_{tsk}(A + \epsilon) - C_{tsk} +  \sum_{t = t_1}^{t_1 + x} task\_i(t)$. }

\textsc{Доказательство.} Утверждение леммы следует из лемм 9 и 10 и транзитивности отношения ($\leq$) для натуральных чисел. $\square$

\textsc{Лемма 12.}
\textit{Рассмотрим константу $R$ и функцию $IBF_{tsk}$, пусть для них выполняется предположение 7,
  тогда для константы $R$ и функции $C_{tsk}AC_{tsk} (A + \epsilon) - (q_{tsk}^{last} - \epsilon) + IBF_{tsk}(A, \cdot)$
  выполняется предположение 4. }

\textsc{Доказательство.} Для того, чтобы доказать, что выполняется предположение 4, нужно показать,
  что для любого $A$ из пространства поиска существует $F$, такое что:
    $A + F =  (C_{tsk} - q_{tsk}^{last} +\epsilon) +  (C_{tsk}AC_{tsk}(A + \epsilon) - C_{tsk}) + IBF_{tsk}(A, A + F)$
    и $F + (q_{tsk}^{last} - \epsilon) \leq R$.
  Можем к данному $A$ применить предположение 7, тогда получим, что существует $F$ такое,
    что выполняются следующие гипотезы:
    $A + F = C_{tsk}AC_{tsk}(A + \epsilon) - (q_{tsk}^{last}- \epsilon) + IBF_{tsk}(A, A + F)$
    и $F + (q_{tsk}^{last}- \epsilon) \leq R$.
  После перестановки термов первой гипотезы можно получить первое заключения,
  а вторая гипотеза полностью идентична второму заключению. $\square$

\textsc{Теорема 7.}
\textit{$R$ является оценкой наихудшего времени ожидания задачи $tsk$. }

\textsc{Доказательство.} Применим теорему 6. Все предположения, необходимые для
  применения теоремы 6, либо в точности повторяют предположения теоремы 7,
  либо могут быть получены применением лемм, доказанных выше. $\square$


% ------------------------------------------------------------------------------
%                             ...
% ------------------------------------------------------------------------------

\section{Теорема о корректности оценки наихудшего времени ожидания для FP\-/планирования}

В данной главе мы воспользуемся теоремой о корректности метода интервала занятости для
  последовательных работ, чтобы получить доказательство теоремы о корректности
  оценки наихудшего времени ожидания для FP\-/планирования.

Модель FP\-/планирования была описана в разделе 1.3, поэтому, далее будет сразу описано
  решение. В данной главе рассматривается конкретная модель (FP\-/планирования), поэтому
  становится возможным указать конкретные $i$ и $w$. Также становится возможным явно
  ввести политики планирования присваивания приоритетов.

Как и в главе 2, рассматривается множество задач $ts$ и выделенная задача $tsk \in ts$,
  для которой необходимо найти оценку наихудшего времени ожидания. Пусть на
  задачах задано рефлексивное, транзитивное отношение приоритетов ($\pi(\cdot) \leq \pi(\cdot)$).

Пусть существуют последовательность прибытия $arr\_seq$ и планировщик $sched$.
  Предполагается, что планировщик обладает некоторыми естественными свойствами.
  Перечислим некоторые из них явно:
    все запланированные работы должны вначале появиться в последовательности прибытия,
    завершённые работы не могут выполняться дальше,
    планировщик должен быть сохраняющим работу в смысле определения Главы 1,
    также предполагается, что работы являются последовательными.

В полной версии приведено доказательство того, что при данных ограничениях
  блокировка низкоприоритетой работой любой работы
  из задачи $tsk$ не может длиться дольше $\max_{\tau:\pi(\tau) < \pi(tsk)} q_{\tau}^{max}$,
  обозначим это значение как $B_{tsk}$.

Введём константу $L > 0$, которая ограничивает максимальную длину интервала занятости
  любой работы $j$ произведенной задачей $tsk$. Константа $L$ должна быть решением
  следующего уравнения: $L = B_{tsk} + \sum_{\tau: \pi(\tau) \geq \pi(tsk)} C_{\tau}AC_{\tau}(L)$.
  В лемме 14 приведено доказательство того факта, что из этого уравнения действительно следует
  ограниченность интервала занятости для любой работы задачи $tsk$.

Введём предикат $is\_priority\_inversion(j, t)$, который истеннен, если
  в момент времени $t$ выполняется работа $j_{lp}$ с более низким приоритетом, чем у работы $j$,
  и ложен в любом другом случае.

Введём предикаты $is\_interf\_from\_hep\_diff\_jobs(j,t)$ и $is\_interf\_from\_hep\_diff\_tasks(t)$.
  Первый из которых истеннен, тогда и только тогда, когда в момент времени $t$ исполняется
  любая работа с более высоким приоритетом, отличная от $j$. А второй --- тогда и только тогда, когда
  в момент времени $t$ исполняется работа с более высоким приоритетом из задачи, отличной от $tsk$.

Введём функции, которые возвращают нагрузку полученную работой или задачей
  в каждый момент времени. Функция $workload\_of\_hep\_diff\_jobs(j,t)$ принимает на вход
  работу и момент времени $t$ и возвращает суммарную стоимость всех работ с более
  высоким приоритетом, которые появились в момент времени $t$.
  Функция $workload\_of\_hep\_diff\_tasks(t)$ принимает на вход момент времени $t$ и возвращает
  суммарную стоимость всех работ с более высоким приоритетом, при условии, что они произведены другой задачей.

Теперь возможно явно определить функцию $i$, введённую в главе 2.
  \begin{align*} i(j,t) = & is\_priority\_inversion(j, t) || \\ & is\_interf\_from\_hep\_diff\_jobs(j,t).\\
  \end{align*}
  Другими словами, работа $j$ испытывает помехи в момент времени $t$, если в момент времени
  $t$ выполняется любая другая работа.

Далее определим функцию $w$.
\begin{align*} w(j,t) = & is\_priority\_inversion(j, t) + \\ & workload\_of\_hep\_diff\_jobs(j,t).\\
\end{align*}
  Таким образом, стоимость всех работ с более высоким приоритетом суммируется.
  Но в моменты времени, когда выполняется работа с более низким приоритетом,
  одна единица помех появляется и сразу же тратится функцией $i$.

\textsc{Замечание 1.} Также можно ввести всевозможные суммарные функции описанных выше функций.
  Однако можно заметить, что, например, функция $is\_interf\_from\_hep\_diff\_jobs(j,\cdot)$
  "забывает" информацию о том, какой работой вызваны помехи.
  Поэтому не всегда может быть очевиден интуитивный смысл такой суммарной функции.
  В полной версии доказаны леммы об эквивалентности введённых функций и их более естественных представлений.
  Например, суммарная функция $is\_interf\_from\_hep\_diff\_jobs(j,\cdot)$ эквивалентна
  сумме сервиса всех работ с более высоким приоритетом. А суммарная функция
  $workload\_of\_hep\_diff\_jobs(j,\cdot)$ равна суммарной стоимости всех работ которые появились
  в рассматриваемом интервале.

Введём определение интервала занятости для случая FP\-/планирования. Всё ещё возможно
  пользоваться определением, данным в Главе 2, однако существует
  более удобное и естественное определение интервала занятости для FP\-/случая.

\textsc{Определение 12.}
\textit{Момент времени $t$ называется тихим временем для работы $j$, если
  любая работа, с более высоким приоритетом, чем у работы $j$,
  которая пришла до момента времени $t$, закончена к моменту времени $t$. }

\textsc{Определение 13.}
\textit{Интервал времени $[t_1, t_2)$ называется префиксом интервала занятости работы $j$,
  если $t_1 < t_2$, $t_1$ --- тихое время, любой момент времени $t \in (t_1, t_2)$ --- не тихое время и
  $a_{j} \in [t_1, t_2)$. }

\textsc{Определение 14.}
\textit{Интервал времени $[t_1, t_2)$ называется интервалом занятости работы $j$,
  если $[t_1, t_2)$ --- префикс интервала занятости работы $j$ и $t_2$ --- тихое время. }

\textsc{Замечание 2.} Можно показать, что интервал занятости в смысле определения 8,
  эквивалентен определению интервала занятости в смысле определения 14.

Определим функцию, ограничивающую помехи работ из задачи $tsk$:
  $$IBF_{tsk}(R) = B_{tsk} + \sum_{\tau:\pi(\tau) \geq \pi(tsk) \wedge \tau \neq tsk} C_{\tau}AC_{\tau}(R).$$


В случае FP\-/планирования, функция $IBF_{tsk}$ не зависит от параметра, поэтому
  не влияет на пространство поиска. Таким образом, пространство поиска должно выглядеть следующим
  образом: $is\_in\_search\_space(A)$ $=$ $(A < L) \wedge (AC_{tsk}(A) \neq AC_{tsk}(A + \epsilon))$,
  далее будет приведено доказательство корректности такого определения.
  Также из вида $IBF_{tsk}$ понятно, как должно выглядеть выражение, которое необходимо
  вычислить для получения оценки наихудшего времени ожидания задачи $tsk$.
  $R$ должно удовлетворять следующему условию: для любого $A$ из пространства поиска
  существует $F$ такое, что: $A + F = B_{tsk} +  C_{tsk}AC_{tsk}(A + \epsilon) - (C_{tsk}^{last} - \epsilon) +
    \sum_{\tau:\pi(\tau) \geq \pi(tsk) \wedge \tau \neq tsk} C_{\tau}AC_{\tau}(A+F)$ и $F + (C_{tsk}^{last} - \epsilon) \leq R$

Далее будут сформулированы и доказаны 5 лемм, которые показывают, что
  текущие $i$, $w$ и $IBF_{tsk}$, при данных предположениях, удовлетворяют всем условиям
  теоремы о корректности метода интервала занятости. А значит, можно воспользоваться ей
  для получения доказательства корректности оценки наихудшего времени ожидания для модели FP\-/планирования.

Докажем, что выполняется условие сохранения работы (предположение 1).
  То есть, рассматриваемый планировщик, при данных предположениях является
  сохраняющим работу в смысле определения сохранения работы данного в главе 2.


\textsc{Лемма 12.}
\textit{Рассматриваемый планировщик является сохраняющим работу в смысле предположения 1.}

\textsc{Доказательство.} Необходимо, чтобы для любой работы $j$ из задачи $tsk$,
  при условии, что существует интервал занятости $[t_1, t_2)$ (в смысле определения 8)
  для работы $j$, и для любого момента времени $t \in [t_1, t_2)$ выполнялось:
   либо работа $j$ выполняется в момент времени $t$, либо $i(j,t) = true$.
  Заключение эквивалентно следующему выражению: работа $j$ выполняется в $t$
    $\Leftrightarrow$ $i(j,t) = false$. Рассмотрим оба случая.

  Пусть $i(j,t) = false$, докажем, что тогда работа $j$ выполняется в момент
    времени $t$. Можно расписать $i(j,t) = false$ по определению.
    Получим: (1) не выполняется работа с более низким приоритетом и (2) не выполняется
    другая работа с приоритетом равным приоритету работы $j$ или выше. Опять рассмотрим
    два случая: либо в момент времени исполняется какая-то произвольная работа $s$, либо не выполняется никакой работы.
  В первом случае, про работу $s$ известно, что для неё выполняются условия (1) и (2).
    Пусть $s \neq j$. Подставим работу $s$ в факт (1), получим, что работа $s$ обладает
    приоритетом не меньшим, чем у работы $j$. Тогда подставим работу $s$ в (2). Но в таком случае получается, это либо работа не с более высоким приоритетом (противоречие), либо равна работе $j$ (противоречие). Получается, что в любом случае, кроме $s = j$, мы получаем противоречие. Тогда получили, что работа
    исполнялась в момент времени $t$, что и требовалось доказать.
  Во втором случае, в момент времени $t$ ничего не выполняется, но это противоречит
    предположению о сохранении работы в смысле определения в главе 3.
  Так как есть как минимум одна ожидающая работа --- $j$, поэтому, планировщик не мог ничего не запланировать.

  В обратную сторону. Пусть работа $j$ выполняется в момент времени $t$, покажем, что $i(j,t) = false$.
    Достаточно просто раскрыть определение $i(j,t)$ и упростить. Так как в момент времени $t$
    исполняется работа не отличная от работы $j$, $i(j,t) = false$.
$\square$


\textsc{Лемма 13.}
\textit{Любой интервал занятости ограничен константой $L$, то есть, выполняется предположение 2. }

\textsc{Доказательство.}  Для доказательства этого утверждения достаточно доказать,
  что любой интервал занятости в смысле определения 14, не длиннее $L$.
  Известно, что $L$ является решение следующего уравнения:
    $L = B_{tsk} + \sum_{\tau: \pi(\tau) \geq \pi(tsk)} C_{\tau}AC_{\tau}(L)$,
    равенство можно ослабить до $\geq$.
  От противного, пусть существует интервал занятости длины больше, чем $L$. Пусть он
    начинается в момент времени $t_1$ и заканчивается в момент времени $t_2$, такой, что $t_2 - t_1 > L$.
  По определению интервала занятости это значит, что в любой момент времени $t \in (t_1, t_2)$
    существует работа с более высоким приоритетом, которая ещё не закончена.
  Так как рассматривается система с одним процессором, возможно выполнить не больше одной
    единицы работы в одну единицу времени, с другой стороны, система также сохраняющая работу
    поэтому внутри интервала не может быть простоев.
  Таким образом, в любой момент времени $t \in [t_1, t_2)$ работы, прибывшей в интервале
    $[t_1, t)$, больше, чем $t - t_1$.
  Но это противоречие. Пусть $t = t_1 + L$, такое $t$ лежит внутри $[t_1, t_2)$.
    С одной стороны, известно, что $L = B_{tsk} + \sum_{\tau: \pi(\tau) \geq \pi(tsk)} C_{\tau}AC_{\tau}(L)$,
      а значит, работы на промежутке не может быть больше, чем $L$ единиц,
    но с другой стороны, её должно быть больше, иначе интервал занятости получится короче, чем $L$.
$\square$


\textsc{Лемма 14.}
\textit{Функции $i$ и $w$ являются согласующимися относительно сервиса
  работ из задачи $tsk$, то есть, справедливо предположение 5. }

\textsc{Доказательство.}  Необходимо доказать, что для любой работы $j$ задачи $tsk$
  и интервала занятости работы $j$ (в смысле определения 8), выполняется условие:
    суммарные помехи задачи $tsk$ в интервале $[0, t_1)$
    равны суммарной нагрузке задачи $tsk$ в интервале $[0, t_1)$.
  По замечанию 2, интервал занятости в смысле определение 8 эквивалентен
    определению интервала занятости в смысле определения 14.
  Так как $t_1$ --- тихое время, любая работа с таким же или более высоким приоритетом,
    которая появилась раньше момента времени $t_1$, будет завершена.
  Следовательно, суммарный сервис и суммарная нагрузка всех работ, с таким же или
    более высоким приоритетом, равны в интервале $[0, t_1)$.
  Из чего следует, что суммарный сервис и суммарная нагрузка задачи $tsk$
    в интервале $[0, t_1)$ тоже равны. $\square$


\textsc{Лемма 15.}
\textit{Функция $IBF_{tsk}$ ограничивает суммарные помехи задачи. }

\textsc{Доказательство.}
  Рассмотрим произвольную работу $j$ задачи $tsk$.
  Существует интервал занятости $[t_1, t_2)$ для работы $j$.
  Суммарные помехи работы $j$ в интервале $[t_1, t_2)$ меньше, чем
    суммарная нагрузка той же работы.
  Докажем, что суммарная нагрузка работы $j$ в интервале $[t_1, t_1 + R) \subseteq [t_1, t_2)$
    меньше, чем $IBF_{tsk}(R)$ или $B_{tsk} + \sum_{\tau: \pi(\tau) \geq \pi(tsk)} C_{\tau}AC_{\tau}(R)$.
  Рассмотрим наихудший случай расписания для работы $j$.
    В наихудшем случае, в момент времени $t_1 - \epsilon$ начал исполняться длиннейший
      сегмент работы с более низким приоритетом. Работы с более низким приоритетом
      не учитываются в интервале занятости, поэтому, интервал занятости может начаться
      даже не смотря на то, что существует незавершённая работа с более низким приоритетом.
    В худшем случае, этот сегмент будет выполняться $B_{tsk}$ единиц времени.

    В интервале времени $[t_1, t_1 + R)$, в худшем случае, может появиться
      $\sum_{\tau: \pi(\tau) \geq \pi(tsk)} AC_{\tau}(R)$ работ.
    Даже если каждая из них будет иметь стоимость равную стоимости задачи,
      в сумме получится не больше, чем $\sum_{\tau: \pi(\tau) \geq \pi(tsk)} C_{\tau}AC_{\tau}(R)$.
    Можно сложить нагрузку работ с более низким приоритетом и нагрузку работ
      с равным или более высоким приоритетом, получим: $B_{tsk} + \sum_{\tau: \pi(\tau) \geq \pi(tsk)} C_{\tau}AC_{\tau}(R)$,
      что не только не превосходит $IBF_{tsk}(R)$, но и совпадает с ней.
    А значит, функция $IBF_{tsk}(R)$ точная и её нельзя улучшить. То есть
      существуют корректные расписания, в которых рассматриваемая работа
      испытывает ровно $IBF_{tsk}(R)$ единиц помех.
$\square$


\textsc{Лемма 16.}
\textit{Для любого $A$ из пространства поиска (в смысле определения 9)
  существует $F$, такое, что:
    $A + F = (AC_{tsk}(A + \epsilon) - q_{tsk}^{last}) + IBF_{tsk}(A, A + F)$
    и $F + (q_{tsk}^{last} - \epsilon) \leq R$.
  То есть, выполняется предположение 7. }

\textsc{Доказательство.} Мы предполагаем, что для каждой $A$ из пространства
  поиска в смысле главы 3 существует $F$, такое, что
    $A + F = (AC_{tsk}(A + \epsilon) - q_{tsk}^{last}) + IBF_{tsk}(A, A + F)$
    и $F + (q_{tsk}^{last} - \epsilon) \leq R$.
  Заключение леммы отличается от этого предположения только тем, что
    в них используются разные понятия пространства поиска.
  Поэтому, если будет доказано, что данное пространство поиска данной главы
    содержит все точки, которые содержатся в пространстве поиска в смысле определения 9,
    лемма будет доказана.

  Пусть $A$ --- точка из пространства поиска в смысле определения 9, докажем, что
    эта же точка принадлежит пространству поиска в смысле определения главы 3.
   Пусть $A = 0$, тогда необходимо доказать:
     (1) $(0 < L)$ и (2) $(AC_{tsk}(0) \neq AC_{tsk}(\epsilon))$.
   Утверждение (1) в данной главе является предположением о $L$.
   Утверждение (2) вытекает из смысла $AC_{tsk}(\cdot)$. В интервале времени длины 0,
     невозможно получить ни одного появления работы, поэтому $AC_{tsk}(0) = 0$,
     но если $AC_{tsk}(\epsilon) = 0$, тогда в интервале любой длины не может
     быть ни одного появления работы. А значит, $AC_{tsk}(\epsilon) > 0$.

   С другой стороны, пусть $A < L$ --- точка, для которой существует $x$, такой, что:
     $C_{tsk}AC_{tsk}(A) - C_{tsk} + IBF_{tsk}(x) \neq C_{tsk}AC_{tsk}(A + \epsilon) - C_{tsk} + IBF_{tsk}(x)$.
   Упростим: $C_{tsk}AC_{tsk}(A) \neq C_{tsk}AC_{tsk}(A + \epsilon)$.
   Но это в точности то, что необходимо было доказать: $(A < L)$ и (2) $(AC_{tsk}(A) \neq AC_{tsk}(A + \epsilon))$.
$\square$


Теперь для доказательства теоремы о корректности оценки наихудшего времени
  ожидания задачи для модели FP\-/планирования, необходимо просто применить теорему
  о корректности метода интервала занятости для случая последовательных работ.
  Выше было доказано, что все условия применяемой теоремы следуют из
  гипотез принятых в этой главе.

\textsc{Теорема 8.}
\textit{$R$ является оценкой наихудшего времени ожидания задачи $tsk$. }

\textsc{Доказательство.}
  Для доказательства данной теоремы необходимо применить теорему о корректности метода
    интервала занятости. Выше было доказано, что все условия этой теоремы следуют
    из условий, предположенных в данной главе.
$\square$


% ------------------------------------------------------------------------------
%                             Теорема о интервале занятости
% ------------------------------------------------------------------------------

\section{Теорема о корректности оценки наихудшего времени ожидания для EDF\-/планирования}

В данной главе будет использована теорема о корректности метода интервала занятости
  для того, чтобы доказать теорему о корректности оценки наихудшего времени ожидания
  для EDF\-/планирования. Для модели EDF\-/планирования возможно воспользоваться такой же схемой получения
  доказательства корректности оценки наихудшего времени ожидания задачи как и для модели FP\-/планирования.

Модель EDF\-/планирования была описана в разделе 1.4, поэтому, далее будет сразу описано
  решение. В данной главе рассматривается конкретная модель (EDF\-/планирования), поэтому
  становится возможным явно указать функции $i$ и $w$. Также становится возможным явно
  ввести политики планирования присваивания приоритетов.

Как и в предыдущих главах, рассматривается множество задач $ts$ и
 выделенная задача $tsk \in ts$ для которой необходимо найти оценку
 наихудшего времени ожидания.

Приоритеты вводятся следующим образом: рассмотрим две произвольные работы
  $j_1$ и $j_2$, работа $j_1$ имеет больший приоритет, чем работа $j_2$,
  если $a_{j_1} + d_{task_{j_1}} < a_{j_2} + d_{task_{j_2}}$. В модели EDF\-/планирования
  относительный дедлайн работы равен относительному дедлайну задачи. Больший
  приоритет имеет та работа, у которой абсолютный дедлайн меньше.

Пусть существуют последовательность прибытия $arr\_seq$ и планировщик $sched$.
  Как и в предыдущих главах, предполагается, что последовательность прибытия и планировщик
  обладают некоторыми естественными свойствами.

В полной версии приведено доказательство того, что при данных ограничениях
  блокировка низкоприоритетой работой любой работы
  из задачи $tsk$ не может длиться дольше $\max_{\tau: \tau \neq tsk} q_{\tau}^{max}$,
  обозначим это значение как $B_{tsk}$. В данной модели максимум берётся по всем задачам,
  не равным рассматриваемой.

Введём константу $L > 0$, которая ограничивает максимальную длину интервала занятости
  любой работы $j$ произведенной задачей $tsk$. Константа $L$ должна быть решением
  следующего уравнения: $L = B_{tsk} + \sum_{\tau: \tau \neq tsk} C_{\tau}AC_{\tau}(L)$.
  Существует более точное уравнение для оценки максимальной длины интервалов занятости, однако
  это сказывается только на пространстве поиска, но не на оценке наихудшего времени ожидания.
  В лемме 18 приведено доказательство того факта, что из этого уравнения действительно следует
  ограниченность интервала занятости для любой работы задачи $tsk$.

Введём функции $i$ и $w$. Их определения
  в точности совпадают с определениями приведёнными в главе 3. Однако из-за
  новой функции определения приоритетов, значения, которые принимают
  функций $i$ и $w$, значительно отличаются от значений функций из главы 3.

Рассмотрим предикат $is\_priority\_inversion(j, t)$, его определение совпадает с определением
  из главы 3. Это предикат, который истеннен, если в момент времени $t$ выполняется
  работа $j_{lp}$ с более низким приоритетом, чем у работы $j$, и ложен в любом другом случае.
  Выражение <<с более низким приоритетом>> теперь означает <<с более поздним дедлайном>>,
  что сильно отличается от аналогичного выражения из главы~3.

Введём функции $i$ и $w$.
  \begin{align*}
    i(j,t) = & is\_priority\_inversion(j, t) || \\
             & is\_interf\_from\_hep\_diff\_jobs(j,t), \\
  w(j,t) = & is\_priority\_inversion(j, t) + \\
           & workload\_of\_hep\_diff\_jobs(j,t).
           \\
  \end{align*}

Введём определение интервала занятости для случая EDF\-/планирования. Оно также
  по форме повторяет определение интервала занятости для случая FP\-/планирования.

\textsc{Определение 15.}
\textit{Момент времени $t$ называется тихим временем для работы $j$, если
  любая работа, с более высоким приоритетом, чем у работы $j$,
  которая пришла до момента времени $t$, закончена к моменту времени $t$. }

\textsc{Определение 16.}
\textit{Интервал времени $[t_1, t_2)$ называется префиксом интервала занятости работы $j$,
  если $t_1 < t_2$, $t_1$ --- тихое время, любой момент времени $t \in (t_1, t_2)$ --- не тихое время и
  $a_{j} \in [t_1, t_2)$. }

\textsc{Определение 17.}
\textit{Интервал времени $[t_1, t_2)$ называется интервалом занятости работы $j$,
  если $[t_1, t_2)$ --- префикс интервала занятости работы $j$ и $t_2$ --- тихое время. }

\textsc{Замечание 3.} Можно показать, что интервал занятости в смысле определения 17,
  эквивалентен определению интервала занятости в смысле определения 8.

Введём функцию ограничивающую помехи работ из задачи $tsk$.
  $$IBF_{tsk}(A, R) = B_{tsk} + \sum_{\tau:\tau \neq tsk} C_{\tau}AC_{\tau}( min\{A + d_{tsk} - d_{\tau} + \epsilon, R\} ).$$

Введём пространство поиска: $is\_in\_search\_space(A)$ $=$
    $(A < L) \wedge
      (AC_{tsk}(A) \neq AC_{tsk}(A + \epsilon)
       \vee \exists \tau: \tau \neq tsk \wedge AC_{\tau}(A + d_{tsk} - d_{\tau}) \neq
                                               AC_{\tau}(A + d_{tsk} - d_{\tau} + \epsilon) )$,
  далее будет приведено доказательство корректности такого определения.
  Из вида функции $IBF_{tsk}$ понятно, как должно выглядеть выражение, которое необходимо
  вычислить для получения оценки наихудшего времени ожидания задачи $tsk$.
  $R$ должно удовлетворять следующему условию: для любого $A$ из пространства поиска
  существует $F$ такое, что: $A + F = B_{tsk} +  C_{tsk}AC_{tsk}(A + \epsilon) - (C_{tsk}^{last} - \epsilon) +
    \sum_{\tau:\pi(\tau) \geq \pi(tsk) \wedge \tau \neq tsk} C_{\tau}AC_{\tau}(A+F)$ и $F + (C_{tsk}^{last} - \epsilon) \leq R$

Далее будут сформулированы и доказаны 5 лемм, которые показывают, что
  текущие $i$, $w$ и $IBF_{tsk}$, при данных предположениях, удовлетворяют всем условиям
  теоремы о корректности метода интервала занятости. А значит, можно воспользоваться ей
  для получения доказательства корректности оценки наихудшего времени ожидания для модели EDF\-/планирования.

Докажем, что выполняется условие сохранения работы (предположение 1).
  То есть, рассматриваемы планировщик, при данных предположениях является
  сохраняющим работу в смысле определения сохранения работы данного в Главе 2.

\textsc{Лемма 17.}
\textit{Рассматриваемый планировщик является сохраняющим работу в смысле предположения 1.}

\textsc{Доказательство.} Доказательство леммы аналогично доказательству леммы 12. $\square$


\textsc{Лемма 18.}
\textit{Любой интервал занятости ограничен константой $L$, то есть, выполняется предположение 2. }

\textsc{Доказательство.} Аналогично доказательству леммы 13. $\square$


\textsc{Лемма 19.}
\textit{Функции $i$ и $w$ являются согласующимися относительно сервиса
  работ из задачи $tsk$, то есть, справедливо предположение 5. }

\textsc{Доказательство.} Аналогично доказательству леммы 14. $\square$


\textsc{Лемма 20.}
\textit{Функция $IBF_{tsk}$ ограничивает суммарные помехи задачи. }

\textsc{Доказательство.}
  Рассмотрим произвольную работу $j$ задачи $tsk$.
  Существует интервал занятости $[t_1, t_2)$ для работы $j$.
  Пусть существует произвольное $R$, такое, что $t_1 + R \in [t_1, t_2)$ и работа $j$
    не завершена в момент времени $t_1 + R$.
  Обозначим относительное время прибытия $a_j - t_1 $ как $A$.
  Тогда необходимо доказать, что суммарные помехи работы $j$ в интервале $[t_1, t_1 + R)$
    меньше, чем $IBF_{tsk}(A, R)$.
  Суммарные помехи работы по определению равны суммарным низкоприоритетным помехам и
    помехам с более высоким приоритетом. А $IBF_{tsk}(A, R)$ расписывается как
    $B_{tsk} + \sum_{\tau:\tau \neq tsk} C_{\tau}AC_{\tau}( min\{A + d_{tsk} - d_{\tau} + \epsilon, R\} )$.
  В полной версии приведено доказательство того факта, что $B_{tsk}$ действительно ограничивает
    помехи с более низким приоритетом. Остаётся показать, что
    $\sum_{\tau:\tau \neq tsk} C_{\tau}AC_{\tau}( min\{A + d_{tsk} - d_{\tau} + \epsilon, R\} )$
    ограничивает помехи с более высоким приоритетом.
  Как и в доказательстве леммы 15, воспользуемся тем фактом, что суммарные помехи
    работы $j$ в интервале $[t_1, t_2)$ не больше, чем суммарная нагрузка той же работы.
  Суммарную нагрузку работ с более высоким приоритетом можно "расслоить" на сумму задач,
    или схематично,
    $\sum_{\tau:\tau \neq tsk}$
      (суммарная нагрузка работ с более высоким приоритетом в интервале $[t_1, t_1 + R)$).
  Получили: $\sum_{\tau:\tau \neq tsk} (\ ... \ )
    \leq\sum_{\tau:\tau \neq tsk} C_{\tau}AC_{\tau}( min\{A + d_{tsk} - d_{\tau} + \epsilon, R\} )$.
  Для доказательства неравенства достаточно показать, что для произвольной задачи $\tau$ ($\neq tsk$).
    Выполняется следующее неравенство: суммарная нагрузка работ из задачи $\tau$ в интервале $[t_1, t_1 + R)$
      не больше, чем $C_{\tau}AC_{\tau}( min\{A + d_{tsk} - d_{\tau} + \epsilon, R\} )$.
  Рассмотрим два случая.

  Рассмотрим случай, когда $R \leq A + d_{tsk} - d_{\tau} + \epsilon$. В этом случае правая часть
    неравенства преобразуется в $C_{\tau}AC_{\tau}(R)$ и доказательство становится
    аналогичным доказательству леммы 15.

  Рассмотрим случай, когда $A + d_{tsk} - d_{\tau} + \epsilon < R$. Получим следующее неравенство:
    суммарная нагрузка работ из задачи $\tau$ в интервале $[t_1, t_1 + R)$
      не больше, чем $C_{\tau}AC_{\tau}(A + d_{tsk} - d_{\tau} + \epsilon)$.
    Можно уточнить правую часть, и заменить на
      $C_{\tau}$ $\cdot$ (количество работ с более высоким приоритетом из задачи $\tau$,
        появившихся в интервале $[t_1, t_1 + A + d_{tsk} - d_{\tau} + \epsilon)$).
  Следующий шаг заключается в следующем: необходимо доказать, что $R$ в левой части неравенства
    можно безопасно заменить на $A + d_{tsk} - d_{\tau} + \epsilon$. Так как $A + d_{tsk} - d_{\tau} + \epsilon < R$,
    это может уменьшить левую часть, а значит, ослабить неравенство. Однако, как будет доказано,
    этого не происходит.
  Для этого докажем, что не существует работ с более высоким приоритетом, которые появились
    в интервале $[t_1 + A + d_{tsk} - d_{\tau} + \epsilon, t_1 + R)$.
  От противного. Пусть у нас есть работа $j_{\tau}$ из задачи $\tau$, она появилась
    в интервале времени $[t_1 + A + d_{tsk} - d_{\tau} + \epsilon, t_1 + R)$, но
    имеет более высокий приоритет, а значит $a_{j_{\tau}} + d_{\tau} \leq a_{j} + d_{tsk}$.
  Однако, из того, что работа $j_{\tau}$ появилась в интервале $[t_1 + A + d_{tsk} - d_{\tau} + \epsilon, t_1 + R)$
    следует то, что , что $a_{j_{\tau}} + d_{\tau} > a_{j} + d_{tsk}$. Получили противоречие.

  Остаётся показать только то, что суммарная нагрузка работ с более высоким приоритетом
    из задачи $\tau$ в интервале $[t_1, t_1 + A + d_{tsk} - d_{\tau} + \epsilon)$ не больше, чем
    $C_{\tau}$ $\cdot$ (количество работ с более высоким приоритетом из задачи $\tau$,
        появившихся в интервале $[t_1, t_1 + A + d_{tsk} - d_{\tau} + \epsilon)$),
    но это простой шаг, который уже был выполнен в доказательстве леммы 15.
$\square$


\textsc{Лемма 21.}
\textit{Для любого $A$ из пространства поиска (в смысле определения 9)
  существует $F$ такое, что:
    $A + F = (AC_{tsk}(A + \epsilon) - q_{tsk}^{last}) + IBF_{tsk}(A, A + F)$
    и $F + (q_{tsk}^{last} - \epsilon) \leq R$.
  То есть, выполняется предположение 7. }

\textsc{Доказательство.}
  Как и в доказательстве леммы 16, всё сводится к тому, чтобы показать,
    что пространство поиска в смысле определения данной главы, не меньше,
    чем пространство поиска в смысле определения 9.

  Пусть $A = 0$, тогда необходимо доказать:
    (1) $(0 < L)$ и (2) $(AC_{tsk}(0) \neq AC_{tsk}(\epsilon))$.
  Утверждение (1) в данной главе является предположением о $L$.
  Утверждение (2) вытекает из смысла $AC_{tsk}(\cdot)$. В интервале времени длины 0,
    невозможно получить ни одного появления работы, поэтому $AC_{tsk}(0) = 0$,
    но если $AC_{tsk}(\epsilon) = 0$, тогда в интервале любой длины не может
    быть ни одного появления работы. А значит, $AC_{tsk}(\epsilon) > 0$.

  С другой стороны, пусть $A < L$ --- точка, для которой существует $x$, такой, что:
   $C_{tsk}AC_{tsk}(A) - C_{tsk} + IBF_{tsk}(A - \epsilon, x) \neq C_{tsk}AC_{tsk}(A + \epsilon) -  C_{tsk} + IBF_{tsk}(A,x)$.
  Необходимо доказать, что:
    (1) $(C_{tsk}AC_{tsk}(A) \neq C_{tsk}AC_{tsk}(A + \epsilon)
          \vee \exists \tau: \tau \neq tsk \wedge C_{\tau}AC_{\tau}(A + d_{tsk} - d_{\tau}) \neq
                                                  C_{\tau}AC_{\tau}(A + d_{tsk} - d_{\tau} + \epsilon))$.

  Докажем от противного. Предположим, что выполняется отрицание (1),
    нужно доказать, что
    $C_{tsk}AC_{tsk}(A) - C_{tsk} + IBF_{tsk}(A - \epsilon, x) = C_{tsk}AC_{tsk}(A + \epsilon) - C_{tsk} + IBF_{tsk}(A,x)$.
  Из (1) следует, что $(1.a)$ $C_{tsk}AC_{tsk}(A) = C_{tsk}AC_{tsk}(A + \epsilon)$
    и $(1.b)$ $(\forall \tau: \tau = tsk \vee C_{\tau}AC_{\tau}(A + d_{tsk} - d_{\tau})
              = C_{\tau}AC_{\tau}(A + d_{tsk} - d_{\tau} + \epsilon)))$.
  Пользуясь равенством $(1.a)$ упростим заключение леммы: $ IBF_{tsk}(A - \epsilon, x) = IBF_{tsk}(A,x)$.
  Раскроем $IBF_{tsk}$ по определению:
    $\sum_{\tau:\tau \neq tsk} C_{\tau}AC_{\tau}( min\{A - 1 + d_{tsk} - d_{\tau} + \epsilon, R\} ) =
     \sum_{\tau:\tau \neq tsk} C_{\tau}AC_{\tau}( min\{A + d_{tsk} - d_{\tau} + \epsilon, R\} )$.
  Для доказательства равенства сумм, достаточно доказать, что для любого элемента множества, по
    которому производится суммирование, значения совпадают, то есть:
  $\forall \tau, \tau \in ts \wedge \tau \neq tsk \rightarrow
     C_{\tau}AC_{\tau}( min\{A - 1 + d_{tsk} - d_{\tau} + \epsilon, R\}) =
     C_{\tau}AC_{\tau}( min\{A + d_{tsk} - d_{\tau} + \epsilon, R\})$.
  Подставим $\tau$ в $(1.b)$, тогда получим, что
    $C_{\tau}AC_{\tau}(A + d_{tsk} - d_{\tau}) = C_{\tau}AC_{\tau}(A + d_{tsk} - d_{\tau} + \epsilon)$,
    что и требовалось доказать. $\square$

\textsc{Теорема 8.}
\textit{$R$ является оценкой наихудшего времени ожидания задачи $tsk$. }

\textsc{Доказательство.}
  Как и в главе 3, для доказательства данной теоремы необходимо применить теорему о корректности метода
    интервала занятости. Выше было доказано, что все условия этой теоремы следуют
    из условий, предположенных в данной главе.
$\square$

% У заключения нет номера главы
\section*{Заключение}
В рамках данной дипломной работы были достигнуты следующие результаты
\begin{itemize}
    \item Выполнено доказательство теоремы о корректности метода интервала занятости в общем виде в интерактивном программном средстве доказательства теорем Coq, сформулирован минимальный набор предположений о планировщике для системы с одним процессором.
    \item Выполнено доказательство теоремы о корректности оценки наихудшего времени ожидания задачи для FP-планирования (следствие теоремы о корректности метода интервала занятости).
    \item Выполнено доказательство теоремы о корректности оценки наихудшего времени ожидания задачи для EDF-планирования (следствие теоремы о корректности метода интервала занятости).
    % \item Готовится публикация
\end{itemize}

Была доказана теорема о корректности метода интервала занятости, которая обобщает
  схему большинства доказательств теорем о корректности оценки наихудшего времени ожидания задачи.
  Вследствие этого, значительно упростилась задача получения доказательств теорем
  о корректности оценки для интересующих моделей планирования, что было
  показано на частных примерах в главах 3 и 4. Задача доказательства таких теорем перестала
  быть творческой. Для получения доказательства теоремы о корректности оценки
  наихудшего времени ожидания задачи для интересующей модели
  планирования достаточно определить соответствующие функции $i$, $w$ и $IBF_{tsk}$
  и доказать, что они обладают свойствами, требуемыми теоремой о корректности метода интервала занятости.
  После этого, выражение для
  вычисления оценки и корректность этого выражения следуют из теоремы о корректности
  метода интервала занятости, доказанной в главе 2.
